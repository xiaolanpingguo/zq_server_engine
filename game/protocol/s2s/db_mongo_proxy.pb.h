// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db_mongo_proxy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_5fmongo_5fproxy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_5fmongo_5fproxy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_5fmongo_5fproxy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_5fmongo_5fproxy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_5fmongo_5fproxy_2eproto;
namespace DB {
class MongoBatchFindReq;
struct MongoBatchFindReqDefaultTypeInternal;
extern MongoBatchFindReqDefaultTypeInternal _MongoBatchFindReq_default_instance_;
class MongoBatchFindRes;
struct MongoBatchFindResDefaultTypeInternal;
extern MongoBatchFindResDefaultTypeInternal _MongoBatchFindRes_default_instance_;
class MongoDBMsg;
struct MongoDBMsgDefaultTypeInternal;
extern MongoDBMsgDefaultTypeInternal _MongoDBMsg_default_instance_;
class MongoFindReq;
struct MongoFindReqDefaultTypeInternal;
extern MongoFindReqDefaultTypeInternal _MongoFindReq_default_instance_;
class MongoFindRes;
struct MongoFindResDefaultTypeInternal;
extern MongoFindResDefaultTypeInternal _MongoFindRes_default_instance_;
class MongoInsertReq;
struct MongoInsertReqDefaultTypeInternal;
extern MongoInsertReqDefaultTypeInternal _MongoInsertReq_default_instance_;
class MongoInsertRes;
struct MongoInsertResDefaultTypeInternal;
extern MongoInsertResDefaultTypeInternal _MongoInsertRes_default_instance_;
class MongoRemoveReq;
struct MongoRemoveReqDefaultTypeInternal;
extern MongoRemoveReqDefaultTypeInternal _MongoRemoveReq_default_instance_;
class MongoRemoveRes;
struct MongoRemoveResDefaultTypeInternal;
extern MongoRemoveResDefaultTypeInternal _MongoRemoveRes_default_instance_;
class MongoSaveReq;
struct MongoSaveReqDefaultTypeInternal;
extern MongoSaveReqDefaultTypeInternal _MongoSaveReq_default_instance_;
class MongoSaveRes;
struct MongoSaveResDefaultTypeInternal;
extern MongoSaveResDefaultTypeInternal _MongoSaveRes_default_instance_;
class MongoUpdateReq;
struct MongoUpdateReqDefaultTypeInternal;
extern MongoUpdateReqDefaultTypeInternal _MongoUpdateReq_default_instance_;
class MongoUpdateRes;
struct MongoUpdateResDefaultTypeInternal;
extern MongoUpdateResDefaultTypeInternal _MongoUpdateRes_default_instance_;
class MongoUserData;
struct MongoUserDataDefaultTypeInternal;
extern MongoUserDataDefaultTypeInternal _MongoUserData_default_instance_;
class ProtoBsonBatchFindData;
struct ProtoBsonBatchFindDataDefaultTypeInternal;
extern ProtoBsonBatchFindDataDefaultTypeInternal _ProtoBsonBatchFindData_default_instance_;
class ProtoBsonData;
struct ProtoBsonDataDefaultTypeInternal;
extern ProtoBsonDataDefaultTypeInternal _ProtoBsonData_default_instance_;
class ProtoBsonObj;
struct ProtoBsonObjDefaultTypeInternal;
extern ProtoBsonObjDefaultTypeInternal _ProtoBsonObj_default_instance_;
}  // namespace DB
PROTOBUF_NAMESPACE_OPEN
template<> ::DB::MongoBatchFindReq* Arena::CreateMaybeMessage<::DB::MongoBatchFindReq>(Arena*);
template<> ::DB::MongoBatchFindRes* Arena::CreateMaybeMessage<::DB::MongoBatchFindRes>(Arena*);
template<> ::DB::MongoDBMsg* Arena::CreateMaybeMessage<::DB::MongoDBMsg>(Arena*);
template<> ::DB::MongoFindReq* Arena::CreateMaybeMessage<::DB::MongoFindReq>(Arena*);
template<> ::DB::MongoFindRes* Arena::CreateMaybeMessage<::DB::MongoFindRes>(Arena*);
template<> ::DB::MongoInsertReq* Arena::CreateMaybeMessage<::DB::MongoInsertReq>(Arena*);
template<> ::DB::MongoInsertRes* Arena::CreateMaybeMessage<::DB::MongoInsertRes>(Arena*);
template<> ::DB::MongoRemoveReq* Arena::CreateMaybeMessage<::DB::MongoRemoveReq>(Arena*);
template<> ::DB::MongoRemoveRes* Arena::CreateMaybeMessage<::DB::MongoRemoveRes>(Arena*);
template<> ::DB::MongoSaveReq* Arena::CreateMaybeMessage<::DB::MongoSaveReq>(Arena*);
template<> ::DB::MongoSaveRes* Arena::CreateMaybeMessage<::DB::MongoSaveRes>(Arena*);
template<> ::DB::MongoUpdateReq* Arena::CreateMaybeMessage<::DB::MongoUpdateReq>(Arena*);
template<> ::DB::MongoUpdateRes* Arena::CreateMaybeMessage<::DB::MongoUpdateRes>(Arena*);
template<> ::DB::MongoUserData* Arena::CreateMaybeMessage<::DB::MongoUserData>(Arena*);
template<> ::DB::ProtoBsonBatchFindData* Arena::CreateMaybeMessage<::DB::ProtoBsonBatchFindData>(Arena*);
template<> ::DB::ProtoBsonData* Arena::CreateMaybeMessage<::DB::ProtoBsonData>(Arena*);
template<> ::DB::ProtoBsonObj* Arena::CreateMaybeMessage<::DB::ProtoBsonObj>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace DB {

enum MongoMsgType : int {
  MONGO_MSG_NULL = 0,
  MONGO_MSG_INSERT_REQ = 1,
  MONGO_MSG_INSERT_RES = 2,
  MONGO_MSG_REMOVE_REQ = 3,
  MONGO_MSG_REMOVE_RES = 4,
  MONGO_MSG_SAVE_REQ = 5,
  MONGO_MSG_SAVE_RES = 6,
  MONGO_MSG_UPDATE_REQ = 7,
  MONGO_MSG_UPDATE_RES = 8,
  MONGO_MSG_FIND_REQ = 9,
  MONGO_MSG_FIND_RES = 10,
  MONGO_MSG_BATCH_FIND_REQ = 11,
  MONGO_MSG_BATCH_FIND_RES = 12,
  MongoMsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MongoMsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MongoMsgType_IsValid(int value);
constexpr MongoMsgType MongoMsgType_MIN = MONGO_MSG_NULL;
constexpr MongoMsgType MongoMsgType_MAX = MONGO_MSG_BATCH_FIND_RES;
constexpr int MongoMsgType_ARRAYSIZE = MongoMsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MongoMsgType_descriptor();
template<typename T>
inline const std::string& MongoMsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MongoMsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MongoMsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MongoMsgType_descriptor(), enum_t_value);
}
inline bool MongoMsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MongoMsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MongoMsgType>(
    MongoMsgType_descriptor(), name, value);
}
// ===================================================================

class ProtoBsonData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.ProtoBsonData) */ {
 public:
  inline ProtoBsonData() : ProtoBsonData(nullptr) {}
  ~ProtoBsonData() override;
  explicit PROTOBUF_CONSTEXPR ProtoBsonData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoBsonData(const ProtoBsonData& from);
  ProtoBsonData(ProtoBsonData&& from) noexcept
    : ProtoBsonData() {
    *this = ::std::move(from);
  }

  inline ProtoBsonData& operator=(const ProtoBsonData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoBsonData& operator=(ProtoBsonData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoBsonData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoBsonData* internal_default_instance() {
    return reinterpret_cast<const ProtoBsonData*>(
               &_ProtoBsonData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProtoBsonData& a, ProtoBsonData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoBsonData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoBsonData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoBsonData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoBsonData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoBsonData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoBsonData& from) {
    ProtoBsonData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoBsonData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.ProtoBsonData";
  }
  protected:
  explicit ProtoBsonData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kVarStringFieldNumber = 7,
    kVarBinFieldNumber = 8,
    kDataTypeFieldNumber = 2,
    kVarInt32FieldNumber = 3,
    kVarInt64FieldNumber = 4,
    kVarDoubleFieldNumber = 5,
    kVarBoolFieldNumber = 6,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string var_string = 7;
  void clear_var_string();
  const std::string& var_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_string();
  PROTOBUF_NODISCARD std::string* release_var_string();
  void set_allocated_var_string(std::string* var_string);
  private:
  const std::string& _internal_var_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_string(const std::string& value);
  std::string* _internal_mutable_var_string();
  public:

  // bytes var_bin = 8;
  void clear_var_bin();
  const std::string& var_bin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_bin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_bin();
  PROTOBUF_NODISCARD std::string* release_var_bin();
  void set_allocated_var_bin(std::string* var_bin);
  private:
  const std::string& _internal_var_bin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_bin(const std::string& value);
  std::string* _internal_mutable_var_bin();
  public:

  // int32 data_type = 2;
  void clear_data_type();
  int32_t data_type() const;
  void set_data_type(int32_t value);
  private:
  int32_t _internal_data_type() const;
  void _internal_set_data_type(int32_t value);
  public:

  // int32 var_int32 = 3;
  void clear_var_int32();
  int32_t var_int32() const;
  void set_var_int32(int32_t value);
  private:
  int32_t _internal_var_int32() const;
  void _internal_set_var_int32(int32_t value);
  public:

  // int64 var_int64 = 4;
  void clear_var_int64();
  int64_t var_int64() const;
  void set_var_int64(int64_t value);
  private:
  int64_t _internal_var_int64() const;
  void _internal_set_var_int64(int64_t value);
  public:

  // double var_double = 5;
  void clear_var_double();
  double var_double() const;
  void set_var_double(double value);
  private:
  double _internal_var_double() const;
  void _internal_set_var_double(double value);
  public:

  // bool var_bool = 6;
  void clear_var_bool();
  bool var_bool() const;
  void set_var_bool(bool value);
  private:
  bool _internal_var_bool() const;
  void _internal_set_var_bool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.ProtoBsonData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_bin_;
    int32_t data_type_;
    int32_t var_int32_;
    int64_t var_int64_;
    double var_double_;
    bool var_bool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class ProtoBsonObj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.ProtoBsonObj) */ {
 public:
  inline ProtoBsonObj() : ProtoBsonObj(nullptr) {}
  ~ProtoBsonObj() override;
  explicit PROTOBUF_CONSTEXPR ProtoBsonObj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoBsonObj(const ProtoBsonObj& from);
  ProtoBsonObj(ProtoBsonObj&& from) noexcept
    : ProtoBsonObj() {
    *this = ::std::move(from);
  }

  inline ProtoBsonObj& operator=(const ProtoBsonObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoBsonObj& operator=(ProtoBsonObj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoBsonObj& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoBsonObj* internal_default_instance() {
    return reinterpret_cast<const ProtoBsonObj*>(
               &_ProtoBsonObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProtoBsonObj& a, ProtoBsonObj& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoBsonObj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoBsonObj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoBsonObj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoBsonObj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoBsonObj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoBsonObj& from) {
    ProtoBsonObj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoBsonObj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.ProtoBsonObj";
  }
  protected:
  explicit ProtoBsonObj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBsonDataListFieldNumber = 1,
  };
  // repeated .DB.ProtoBsonData bson_data_list = 1;
  int bson_data_list_size() const;
  private:
  int _internal_bson_data_list_size() const;
  public:
  void clear_bson_data_list();
  ::DB::ProtoBsonData* mutable_bson_data_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonData >*
      mutable_bson_data_list();
  private:
  const ::DB::ProtoBsonData& _internal_bson_data_list(int index) const;
  ::DB::ProtoBsonData* _internal_add_bson_data_list();
  public:
  const ::DB::ProtoBsonData& bson_data_list(int index) const;
  ::DB::ProtoBsonData* add_bson_data_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonData >&
      bson_data_list() const;

  // @@protoc_insertion_point(class_scope:DB.ProtoBsonObj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonData > bson_data_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoUserData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoUserData) */ {
 public:
  inline MongoUserData() : MongoUserData(nullptr) {}
  ~MongoUserData() override;
  explicit PROTOBUF_CONSTEXPR MongoUserData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoUserData(const MongoUserData& from);
  MongoUserData(MongoUserData&& from) noexcept
    : MongoUserData() {
    *this = ::std::move(from);
  }

  inline MongoUserData& operator=(const MongoUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoUserData& operator=(MongoUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoUserData* internal_default_instance() {
    return reinterpret_cast<const MongoUserData*>(
               &_MongoUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MongoUserData& a, MongoUserData& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoUserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoUserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoUserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoUserData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoUserData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoUserData& from) {
    MongoUserData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoUserData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoUserData";
  }
  protected:
  explicit MongoUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountIdFieldNumber = 4,
    kSdkUserIdFieldNumber = 8,
    kStrVar1FieldNumber = 13,
    kStrVar2FieldNumber = 14,
    kTransGidFieldNumber = 2,
    kSessionGidFieldNumber = 3,
    kPlayerGidFieldNumber = 5,
    kTypeFieldNumber = 1,
    kSvrIdFieldNumber = 9,
    kOtherPlayerGidFieldNumber = 6,
    kOfflineMsgGidFieldNumber = 7,
    kIntVar1FieldNumber = 10,
    kIntVar2FieldNumber = 11,
    kIntVar3FieldNumber = 12,
  };
  // string account_id = 4;
  void clear_account_id();
  const std::string& account_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_id();
  PROTOBUF_NODISCARD std::string* release_account_id();
  void set_allocated_account_id(std::string* account_id);
  private:
  const std::string& _internal_account_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_id(const std::string& value);
  std::string* _internal_mutable_account_id();
  public:

  // string sdk_user_id = 8;
  void clear_sdk_user_id();
  const std::string& sdk_user_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdk_user_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdk_user_id();
  PROTOBUF_NODISCARD std::string* release_sdk_user_id();
  void set_allocated_sdk_user_id(std::string* sdk_user_id);
  private:
  const std::string& _internal_sdk_user_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdk_user_id(const std::string& value);
  std::string* _internal_mutable_sdk_user_id();
  public:

  // string str_var1 = 13;
  void clear_str_var1();
  const std::string& str_var1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_var1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_var1();
  PROTOBUF_NODISCARD std::string* release_str_var1();
  void set_allocated_str_var1(std::string* str_var1);
  private:
  const std::string& _internal_str_var1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_var1(const std::string& value);
  std::string* _internal_mutable_str_var1();
  public:

  // string str_var2 = 14;
  void clear_str_var2();
  const std::string& str_var2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_var2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_var2();
  PROTOBUF_NODISCARD std::string* release_str_var2();
  void set_allocated_str_var2(std::string* str_var2);
  private:
  const std::string& _internal_str_var2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_var2(const std::string& value);
  std::string* _internal_mutable_str_var2();
  public:

  // uint64 trans_gid = 2;
  void clear_trans_gid();
  uint64_t trans_gid() const;
  void set_trans_gid(uint64_t value);
  private:
  uint64_t _internal_trans_gid() const;
  void _internal_set_trans_gid(uint64_t value);
  public:

  // uint64 session_gid = 3;
  void clear_session_gid();
  uint64_t session_gid() const;
  void set_session_gid(uint64_t value);
  private:
  uint64_t _internal_session_gid() const;
  void _internal_set_session_gid(uint64_t value);
  public:

  // uint64 player_gid = 5;
  void clear_player_gid();
  uint64_t player_gid() const;
  void set_player_gid(uint64_t value);
  private:
  uint64_t _internal_player_gid() const;
  void _internal_set_player_gid(uint64_t value);
  public:

  // int32 type = 1;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // int32 svr_id = 9;
  void clear_svr_id();
  int32_t svr_id() const;
  void set_svr_id(int32_t value);
  private:
  int32_t _internal_svr_id() const;
  void _internal_set_svr_id(int32_t value);
  public:

  // uint64 other_player_gid = 6;
  void clear_other_player_gid();
  uint64_t other_player_gid() const;
  void set_other_player_gid(uint64_t value);
  private:
  uint64_t _internal_other_player_gid() const;
  void _internal_set_other_player_gid(uint64_t value);
  public:

  // uint64 offline_msg_gid = 7;
  void clear_offline_msg_gid();
  uint64_t offline_msg_gid() const;
  void set_offline_msg_gid(uint64_t value);
  private:
  uint64_t _internal_offline_msg_gid() const;
  void _internal_set_offline_msg_gid(uint64_t value);
  public:

  // int32 int_var1 = 10;
  void clear_int_var1();
  int32_t int_var1() const;
  void set_int_var1(int32_t value);
  private:
  int32_t _internal_int_var1() const;
  void _internal_set_int_var1(int32_t value);
  public:

  // int32 int_var2 = 11;
  void clear_int_var2();
  int32_t int_var2() const;
  void set_int_var2(int32_t value);
  private:
  int32_t _internal_int_var2() const;
  void _internal_set_int_var2(int32_t value);
  public:

  // int32 int_var3 = 12;
  void clear_int_var3();
  int32_t int_var3() const;
  void set_int_var3(int32_t value);
  private:
  int32_t _internal_int_var3() const;
  void _internal_set_int_var3(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoUserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdk_user_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_var1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_var2_;
    uint64_t trans_gid_;
    uint64_t session_gid_;
    uint64_t player_gid_;
    int32_t type_;
    int32_t svr_id_;
    uint64_t other_player_gid_;
    uint64_t offline_msg_gid_;
    int32_t int_var1_;
    int32_t int_var2_;
    int32_t int_var3_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoInsertReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoInsertReq) */ {
 public:
  inline MongoInsertReq() : MongoInsertReq(nullptr) {}
  ~MongoInsertReq() override;
  explicit PROTOBUF_CONSTEXPR MongoInsertReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoInsertReq(const MongoInsertReq& from);
  MongoInsertReq(MongoInsertReq&& from) noexcept
    : MongoInsertReq() {
    *this = ::std::move(from);
  }

  inline MongoInsertReq& operator=(const MongoInsertReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoInsertReq& operator=(MongoInsertReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoInsertReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoInsertReq* internal_default_instance() {
    return reinterpret_cast<const MongoInsertReq*>(
               &_MongoInsertReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MongoInsertReq& a, MongoInsertReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoInsertReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoInsertReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoInsertReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoInsertReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoInsertReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoInsertReq& from) {
    MongoInsertReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoInsertReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoInsertReq";
  }
  protected:
  explicit MongoInsertReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kDocFieldNumber = 3,
    kUserDataFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .DB.ProtoBsonObj doc = 3;
  bool has_doc() const;
  private:
  bool _internal_has_doc() const;
  public:
  void clear_doc();
  const ::DB::ProtoBsonObj& doc() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_doc();
  ::DB::ProtoBsonObj* mutable_doc();
  void set_allocated_doc(::DB::ProtoBsonObj* doc);
  private:
  const ::DB::ProtoBsonObj& _internal_doc() const;
  ::DB::ProtoBsonObj* _internal_mutable_doc();
  public:
  void unsafe_arena_set_allocated_doc(
      ::DB::ProtoBsonObj* doc);
  ::DB::ProtoBsonObj* unsafe_arena_release_doc();

  // .DB.MongoUserData user_data = 4;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // @@protoc_insertion_point(class_scope:DB.MongoInsertReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::DB::ProtoBsonObj* doc_;
    ::DB::MongoUserData* user_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoInsertRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoInsertRes) */ {
 public:
  inline MongoInsertRes() : MongoInsertRes(nullptr) {}
  ~MongoInsertRes() override;
  explicit PROTOBUF_CONSTEXPR MongoInsertRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoInsertRes(const MongoInsertRes& from);
  MongoInsertRes(MongoInsertRes&& from) noexcept
    : MongoInsertRes() {
    *this = ::std::move(from);
  }

  inline MongoInsertRes& operator=(const MongoInsertRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoInsertRes& operator=(MongoInsertRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoInsertRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoInsertRes* internal_default_instance() {
    return reinterpret_cast<const MongoInsertRes*>(
               &_MongoInsertRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MongoInsertRes& a, MongoInsertRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoInsertRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoInsertRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoInsertRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoInsertRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoInsertRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoInsertRes& from) {
    MongoInsertRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoInsertRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoInsertRes";
  }
  protected:
  explicit MongoInsertRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSucceedFieldNumber = 1,
  };
  // .DB.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // bool succeed = 1;
  void clear_succeed();
  bool succeed() const;
  void set_succeed(bool value);
  private:
  bool _internal_succeed() const;
  void _internal_set_succeed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoInsertRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DB::MongoUserData* user_data_;
    bool succeed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoRemoveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoRemoveReq) */ {
 public:
  inline MongoRemoveReq() : MongoRemoveReq(nullptr) {}
  ~MongoRemoveReq() override;
  explicit PROTOBUF_CONSTEXPR MongoRemoveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoRemoveReq(const MongoRemoveReq& from);
  MongoRemoveReq(MongoRemoveReq&& from) noexcept
    : MongoRemoveReq() {
    *this = ::std::move(from);
  }

  inline MongoRemoveReq& operator=(const MongoRemoveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoRemoveReq& operator=(MongoRemoveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoRemoveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoRemoveReq* internal_default_instance() {
    return reinterpret_cast<const MongoRemoveReq*>(
               &_MongoRemoveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MongoRemoveReq& a, MongoRemoveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoRemoveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoRemoveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoRemoveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoRemoveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoRemoveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoRemoveReq& from) {
    MongoRemoveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoRemoveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoRemoveReq";
  }
  protected:
  explicit MongoRemoveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kSelectorFieldNumber = 3,
    kUserDataFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .DB.ProtoBsonObj selector = 3;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::DB::ProtoBsonObj& selector() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_selector();
  ::DB::ProtoBsonObj* mutable_selector();
  void set_allocated_selector(::DB::ProtoBsonObj* selector);
  private:
  const ::DB::ProtoBsonObj& _internal_selector() const;
  ::DB::ProtoBsonObj* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::DB::ProtoBsonObj* selector);
  ::DB::ProtoBsonObj* unsafe_arena_release_selector();

  // .DB.MongoUserData user_data = 4;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // @@protoc_insertion_point(class_scope:DB.MongoRemoveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::DB::ProtoBsonObj* selector_;
    ::DB::MongoUserData* user_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoRemoveRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoRemoveRes) */ {
 public:
  inline MongoRemoveRes() : MongoRemoveRes(nullptr) {}
  ~MongoRemoveRes() override;
  explicit PROTOBUF_CONSTEXPR MongoRemoveRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoRemoveRes(const MongoRemoveRes& from);
  MongoRemoveRes(MongoRemoveRes&& from) noexcept
    : MongoRemoveRes() {
    *this = ::std::move(from);
  }

  inline MongoRemoveRes& operator=(const MongoRemoveRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoRemoveRes& operator=(MongoRemoveRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoRemoveRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoRemoveRes* internal_default_instance() {
    return reinterpret_cast<const MongoRemoveRes*>(
               &_MongoRemoveRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MongoRemoveRes& a, MongoRemoveRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoRemoveRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoRemoveRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoRemoveRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoRemoveRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoRemoveRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoRemoveRes& from) {
    MongoRemoveRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoRemoveRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoRemoveRes";
  }
  protected:
  explicit MongoRemoveRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSucceedFieldNumber = 1,
  };
  // .DB.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // bool succeed = 1;
  void clear_succeed();
  bool succeed() const;
  void set_succeed(bool value);
  private:
  bool _internal_succeed() const;
  void _internal_set_succeed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoRemoveRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DB::MongoUserData* user_data_;
    bool succeed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoSaveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoSaveReq) */ {
 public:
  inline MongoSaveReq() : MongoSaveReq(nullptr) {}
  ~MongoSaveReq() override;
  explicit PROTOBUF_CONSTEXPR MongoSaveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoSaveReq(const MongoSaveReq& from);
  MongoSaveReq(MongoSaveReq&& from) noexcept
    : MongoSaveReq() {
    *this = ::std::move(from);
  }

  inline MongoSaveReq& operator=(const MongoSaveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoSaveReq& operator=(MongoSaveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoSaveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoSaveReq* internal_default_instance() {
    return reinterpret_cast<const MongoSaveReq*>(
               &_MongoSaveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MongoSaveReq& a, MongoSaveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoSaveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoSaveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoSaveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoSaveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoSaveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoSaveReq& from) {
    MongoSaveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoSaveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoSaveReq";
  }
  protected:
  explicit MongoSaveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kDocFieldNumber = 3,
    kUserDataFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .DB.ProtoBsonObj doc = 3;
  bool has_doc() const;
  private:
  bool _internal_has_doc() const;
  public:
  void clear_doc();
  const ::DB::ProtoBsonObj& doc() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_doc();
  ::DB::ProtoBsonObj* mutable_doc();
  void set_allocated_doc(::DB::ProtoBsonObj* doc);
  private:
  const ::DB::ProtoBsonObj& _internal_doc() const;
  ::DB::ProtoBsonObj* _internal_mutable_doc();
  public:
  void unsafe_arena_set_allocated_doc(
      ::DB::ProtoBsonObj* doc);
  ::DB::ProtoBsonObj* unsafe_arena_release_doc();

  // .DB.MongoUserData user_data = 4;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // @@protoc_insertion_point(class_scope:DB.MongoSaveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::DB::ProtoBsonObj* doc_;
    ::DB::MongoUserData* user_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoSaveRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoSaveRes) */ {
 public:
  inline MongoSaveRes() : MongoSaveRes(nullptr) {}
  ~MongoSaveRes() override;
  explicit PROTOBUF_CONSTEXPR MongoSaveRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoSaveRes(const MongoSaveRes& from);
  MongoSaveRes(MongoSaveRes&& from) noexcept
    : MongoSaveRes() {
    *this = ::std::move(from);
  }

  inline MongoSaveRes& operator=(const MongoSaveRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoSaveRes& operator=(MongoSaveRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoSaveRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoSaveRes* internal_default_instance() {
    return reinterpret_cast<const MongoSaveRes*>(
               &_MongoSaveRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MongoSaveRes& a, MongoSaveRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoSaveRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoSaveRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoSaveRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoSaveRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoSaveRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoSaveRes& from) {
    MongoSaveRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoSaveRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoSaveRes";
  }
  protected:
  explicit MongoSaveRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSucceedFieldNumber = 1,
  };
  // .DB.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // bool succeed = 1;
  void clear_succeed();
  bool succeed() const;
  void set_succeed(bool value);
  private:
  bool _internal_succeed() const;
  void _internal_set_succeed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoSaveRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DB::MongoUserData* user_data_;
    bool succeed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoUpdateReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoUpdateReq) */ {
 public:
  inline MongoUpdateReq() : MongoUpdateReq(nullptr) {}
  ~MongoUpdateReq() override;
  explicit PROTOBUF_CONSTEXPR MongoUpdateReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoUpdateReq(const MongoUpdateReq& from);
  MongoUpdateReq(MongoUpdateReq&& from) noexcept
    : MongoUpdateReq() {
    *this = ::std::move(from);
  }

  inline MongoUpdateReq& operator=(const MongoUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoUpdateReq& operator=(MongoUpdateReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoUpdateReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoUpdateReq* internal_default_instance() {
    return reinterpret_cast<const MongoUpdateReq*>(
               &_MongoUpdateReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MongoUpdateReq& a, MongoUpdateReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoUpdateReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoUpdateReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoUpdateReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoUpdateReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoUpdateReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoUpdateReq& from) {
    MongoUpdateReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoUpdateReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoUpdateReq";
  }
  protected:
  explicit MongoUpdateReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kSelectorFieldNumber = 3,
    kUpdatorFieldNumber = 4,
    kUserDataFieldNumber = 5,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .DB.ProtoBsonObj selector = 3;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::DB::ProtoBsonObj& selector() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_selector();
  ::DB::ProtoBsonObj* mutable_selector();
  void set_allocated_selector(::DB::ProtoBsonObj* selector);
  private:
  const ::DB::ProtoBsonObj& _internal_selector() const;
  ::DB::ProtoBsonObj* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::DB::ProtoBsonObj* selector);
  ::DB::ProtoBsonObj* unsafe_arena_release_selector();

  // .DB.ProtoBsonObj updator = 4;
  bool has_updator() const;
  private:
  bool _internal_has_updator() const;
  public:
  void clear_updator();
  const ::DB::ProtoBsonObj& updator() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_updator();
  ::DB::ProtoBsonObj* mutable_updator();
  void set_allocated_updator(::DB::ProtoBsonObj* updator);
  private:
  const ::DB::ProtoBsonObj& _internal_updator() const;
  ::DB::ProtoBsonObj* _internal_mutable_updator();
  public:
  void unsafe_arena_set_allocated_updator(
      ::DB::ProtoBsonObj* updator);
  ::DB::ProtoBsonObj* unsafe_arena_release_updator();

  // .DB.MongoUserData user_data = 5;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // @@protoc_insertion_point(class_scope:DB.MongoUpdateReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::DB::ProtoBsonObj* selector_;
    ::DB::ProtoBsonObj* updator_;
    ::DB::MongoUserData* user_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoUpdateRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoUpdateRes) */ {
 public:
  inline MongoUpdateRes() : MongoUpdateRes(nullptr) {}
  ~MongoUpdateRes() override;
  explicit PROTOBUF_CONSTEXPR MongoUpdateRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoUpdateRes(const MongoUpdateRes& from);
  MongoUpdateRes(MongoUpdateRes&& from) noexcept
    : MongoUpdateRes() {
    *this = ::std::move(from);
  }

  inline MongoUpdateRes& operator=(const MongoUpdateRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoUpdateRes& operator=(MongoUpdateRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoUpdateRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoUpdateRes* internal_default_instance() {
    return reinterpret_cast<const MongoUpdateRes*>(
               &_MongoUpdateRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MongoUpdateRes& a, MongoUpdateRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoUpdateRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoUpdateRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoUpdateRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoUpdateRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoUpdateRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoUpdateRes& from) {
    MongoUpdateRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoUpdateRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoUpdateRes";
  }
  protected:
  explicit MongoUpdateRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSucceedFieldNumber = 1,
  };
  // .DB.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // bool succeed = 1;
  void clear_succeed();
  bool succeed() const;
  void set_succeed(bool value);
  private:
  bool _internal_succeed() const;
  void _internal_set_succeed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoUpdateRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DB::MongoUserData* user_data_;
    bool succeed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoFindReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoFindReq) */ {
 public:
  inline MongoFindReq() : MongoFindReq(nullptr) {}
  ~MongoFindReq() override;
  explicit PROTOBUF_CONSTEXPR MongoFindReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoFindReq(const MongoFindReq& from);
  MongoFindReq(MongoFindReq&& from) noexcept
    : MongoFindReq() {
    *this = ::std::move(from);
  }

  inline MongoFindReq& operator=(const MongoFindReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoFindReq& operator=(MongoFindReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoFindReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoFindReq* internal_default_instance() {
    return reinterpret_cast<const MongoFindReq*>(
               &_MongoFindReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MongoFindReq& a, MongoFindReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoFindReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoFindReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoFindReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoFindReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoFindReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoFindReq& from) {
    MongoFindReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoFindReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoFindReq";
  }
  protected:
  explicit MongoFindReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kQueryFieldNumber = 3,
    kFieldsFieldNumber = 4,
    kUserDataFieldNumber = 9,
    kLogicBatchNumFieldNumber = 5,
    kSkipFieldNumber = 6,
    kLimitFieldNumber = 7,
    kBatchSizeFieldNumber = 8,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .DB.ProtoBsonObj query = 3;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::DB::ProtoBsonObj& query() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_query();
  ::DB::ProtoBsonObj* mutable_query();
  void set_allocated_query(::DB::ProtoBsonObj* query);
  private:
  const ::DB::ProtoBsonObj& _internal_query() const;
  ::DB::ProtoBsonObj* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::DB::ProtoBsonObj* query);
  ::DB::ProtoBsonObj* unsafe_arena_release_query();

  // .DB.ProtoBsonObj fields = 4;
  bool has_fields() const;
  private:
  bool _internal_has_fields() const;
  public:
  void clear_fields();
  const ::DB::ProtoBsonObj& fields() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_fields();
  ::DB::ProtoBsonObj* mutable_fields();
  void set_allocated_fields(::DB::ProtoBsonObj* fields);
  private:
  const ::DB::ProtoBsonObj& _internal_fields() const;
  ::DB::ProtoBsonObj* _internal_mutable_fields();
  public:
  void unsafe_arena_set_allocated_fields(
      ::DB::ProtoBsonObj* fields);
  ::DB::ProtoBsonObj* unsafe_arena_release_fields();

  // .DB.MongoUserData user_data = 9;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // int32 logic_batch_num = 5;
  void clear_logic_batch_num();
  int32_t logic_batch_num() const;
  void set_logic_batch_num(int32_t value);
  private:
  int32_t _internal_logic_batch_num() const;
  void _internal_set_logic_batch_num(int32_t value);
  public:

  // int32 skip = 6;
  void clear_skip();
  int32_t skip() const;
  void set_skip(int32_t value);
  private:
  int32_t _internal_skip() const;
  void _internal_set_skip(int32_t value);
  public:

  // int32 limit = 7;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 batch_size = 8;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoFindReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::DB::ProtoBsonObj* query_;
    ::DB::ProtoBsonObj* fields_;
    ::DB::MongoUserData* user_data_;
    int32_t logic_batch_num_;
    int32_t skip_;
    int32_t limit_;
    int32_t batch_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoFindRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoFindRes) */ {
 public:
  inline MongoFindRes() : MongoFindRes(nullptr) {}
  ~MongoFindRes() override;
  explicit PROTOBUF_CONSTEXPR MongoFindRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoFindRes(const MongoFindRes& from);
  MongoFindRes(MongoFindRes&& from) noexcept
    : MongoFindRes() {
    *this = ::std::move(from);
  }

  inline MongoFindRes& operator=(const MongoFindRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoFindRes& operator=(MongoFindRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoFindRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoFindRes* internal_default_instance() {
    return reinterpret_cast<const MongoFindRes*>(
               &_MongoFindRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MongoFindRes& a, MongoFindRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoFindRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoFindRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoFindRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoFindRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoFindRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoFindRes& from) {
    MongoFindRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoFindRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoFindRes";
  }
  protected:
  explicit MongoFindRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 3,
    kUserDataFieldNumber = 4,
    kSucceedFieldNumber = 1,
    kHasMoreFieldNumber = 2,
  };
  // repeated .DB.ProtoBsonObj data_list = 3;
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;
  public:
  void clear_data_list();
  ::DB::ProtoBsonObj* mutable_data_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >*
      mutable_data_list();
  private:
  const ::DB::ProtoBsonObj& _internal_data_list(int index) const;
  ::DB::ProtoBsonObj* _internal_add_data_list();
  public:
  const ::DB::ProtoBsonObj& data_list(int index) const;
  ::DB::ProtoBsonObj* add_data_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >&
      data_list() const;

  // .DB.MongoUserData user_data = 4;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // bool succeed = 1;
  void clear_succeed();
  bool succeed() const;
  void set_succeed(bool value);
  private:
  bool _internal_succeed() const;
  void _internal_set_succeed(bool value);
  public:

  // bool has_more = 2;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoFindRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj > data_list_;
    ::DB::MongoUserData* user_data_;
    bool succeed_;
    bool has_more_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class ProtoBsonBatchFindData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.ProtoBsonBatchFindData) */ {
 public:
  inline ProtoBsonBatchFindData() : ProtoBsonBatchFindData(nullptr) {}
  ~ProtoBsonBatchFindData() override;
  explicit PROTOBUF_CONSTEXPR ProtoBsonBatchFindData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoBsonBatchFindData(const ProtoBsonBatchFindData& from);
  ProtoBsonBatchFindData(ProtoBsonBatchFindData&& from) noexcept
    : ProtoBsonBatchFindData() {
    *this = ::std::move(from);
  }

  inline ProtoBsonBatchFindData& operator=(const ProtoBsonBatchFindData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoBsonBatchFindData& operator=(ProtoBsonBatchFindData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoBsonBatchFindData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoBsonBatchFindData* internal_default_instance() {
    return reinterpret_cast<const ProtoBsonBatchFindData*>(
               &_ProtoBsonBatchFindData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProtoBsonBatchFindData& a, ProtoBsonBatchFindData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoBsonBatchFindData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoBsonBatchFindData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoBsonBatchFindData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoBsonBatchFindData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoBsonBatchFindData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoBsonBatchFindData& from) {
    ProtoBsonBatchFindData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoBsonBatchFindData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.ProtoBsonBatchFindData";
  }
  protected:
  explicit ProtoBsonBatchFindData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInt32VarListFieldNumber = 3,
    kInt64VarListFieldNumber = 4,
    kStringVarListFieldNumber = 5,
    kKeyFieldNumber = 1,
    kDataTypeFieldNumber = 2,
  };
  // repeated int32 int32_var_list = 3;
  int int32_var_list_size() const;
  private:
  int _internal_int32_var_list_size() const;
  public:
  void clear_int32_var_list();
  private:
  int32_t _internal_int32_var_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_int32_var_list() const;
  void _internal_add_int32_var_list(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_int32_var_list();
  public:
  int32_t int32_var_list(int index) const;
  void set_int32_var_list(int index, int32_t value);
  void add_int32_var_list(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      int32_var_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_int32_var_list();

  // repeated int64 int64_var_list = 4;
  int int64_var_list_size() const;
  private:
  int _internal_int64_var_list_size() const;
  public:
  void clear_int64_var_list();
  private:
  int64_t _internal_int64_var_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_int64_var_list() const;
  void _internal_add_int64_var_list(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_int64_var_list();
  public:
  int64_t int64_var_list(int index) const;
  void set_int64_var_list(int index, int64_t value);
  void add_int64_var_list(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      int64_var_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_int64_var_list();

  // repeated string string_var_list = 5;
  int string_var_list_size() const;
  private:
  int _internal_string_var_list_size() const;
  public:
  void clear_string_var_list();
  const std::string& string_var_list(int index) const;
  std::string* mutable_string_var_list(int index);
  void set_string_var_list(int index, const std::string& value);
  void set_string_var_list(int index, std::string&& value);
  void set_string_var_list(int index, const char* value);
  void set_string_var_list(int index, const char* value, size_t size);
  std::string* add_string_var_list();
  void add_string_var_list(const std::string& value);
  void add_string_var_list(std::string&& value);
  void add_string_var_list(const char* value);
  void add_string_var_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_var_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_var_list();
  private:
  const std::string& _internal_string_var_list(int index) const;
  std::string* _internal_add_string_var_list();
  public:

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 data_type = 2;
  void clear_data_type();
  int32_t data_type() const;
  void set_data_type(int32_t value);
  private:
  int32_t _internal_data_type() const;
  void _internal_set_data_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DB.ProtoBsonBatchFindData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > int32_var_list_;
    mutable std::atomic<int> _int32_var_list_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > int64_var_list_;
    mutable std::atomic<int> _int64_var_list_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_var_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int32_t data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoBatchFindReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoBatchFindReq) */ {
 public:
  inline MongoBatchFindReq() : MongoBatchFindReq(nullptr) {}
  ~MongoBatchFindReq() override;
  explicit PROTOBUF_CONSTEXPR MongoBatchFindReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoBatchFindReq(const MongoBatchFindReq& from);
  MongoBatchFindReq(MongoBatchFindReq&& from) noexcept
    : MongoBatchFindReq() {
    *this = ::std::move(from);
  }

  inline MongoBatchFindReq& operator=(const MongoBatchFindReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoBatchFindReq& operator=(MongoBatchFindReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoBatchFindReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoBatchFindReq* internal_default_instance() {
    return reinterpret_cast<const MongoBatchFindReq*>(
               &_MongoBatchFindReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MongoBatchFindReq& a, MongoBatchFindReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoBatchFindReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoBatchFindReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoBatchFindReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoBatchFindReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoBatchFindReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoBatchFindReq& from) {
    MongoBatchFindReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoBatchFindReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoBatchFindReq";
  }
  protected:
  explicit MongoBatchFindReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kQueryFieldNumber = 3,
    kFieldsFieldNumber = 4,
    kUserDataFieldNumber = 9,
    kLogicBatchNumFieldNumber = 5,
    kSkipFieldNumber = 6,
    kLimitFieldNumber = 7,
    kBatchSizeFieldNumber = 8,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .DB.ProtoBsonBatchFindData query = 3;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::DB::ProtoBsonBatchFindData& query() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonBatchFindData* release_query();
  ::DB::ProtoBsonBatchFindData* mutable_query();
  void set_allocated_query(::DB::ProtoBsonBatchFindData* query);
  private:
  const ::DB::ProtoBsonBatchFindData& _internal_query() const;
  ::DB::ProtoBsonBatchFindData* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::DB::ProtoBsonBatchFindData* query);
  ::DB::ProtoBsonBatchFindData* unsafe_arena_release_query();

  // .DB.ProtoBsonObj fields = 4;
  bool has_fields() const;
  private:
  bool _internal_has_fields() const;
  public:
  void clear_fields();
  const ::DB::ProtoBsonObj& fields() const;
  PROTOBUF_NODISCARD ::DB::ProtoBsonObj* release_fields();
  ::DB::ProtoBsonObj* mutable_fields();
  void set_allocated_fields(::DB::ProtoBsonObj* fields);
  private:
  const ::DB::ProtoBsonObj& _internal_fields() const;
  ::DB::ProtoBsonObj* _internal_mutable_fields();
  public:
  void unsafe_arena_set_allocated_fields(
      ::DB::ProtoBsonObj* fields);
  ::DB::ProtoBsonObj* unsafe_arena_release_fields();

  // .DB.MongoUserData user_data = 9;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // int32 logic_batch_num = 5;
  void clear_logic_batch_num();
  int32_t logic_batch_num() const;
  void set_logic_batch_num(int32_t value);
  private:
  int32_t _internal_logic_batch_num() const;
  void _internal_set_logic_batch_num(int32_t value);
  public:

  // int32 skip = 6;
  void clear_skip();
  int32_t skip() const;
  void set_skip(int32_t value);
  private:
  int32_t _internal_skip() const;
  void _internal_set_skip(int32_t value);
  public:

  // int32 limit = 7;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 batch_size = 8;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoBatchFindReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::DB::ProtoBsonBatchFindData* query_;
    ::DB::ProtoBsonObj* fields_;
    ::DB::MongoUserData* user_data_;
    int32_t logic_batch_num_;
    int32_t skip_;
    int32_t limit_;
    int32_t batch_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoBatchFindRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoBatchFindRes) */ {
 public:
  inline MongoBatchFindRes() : MongoBatchFindRes(nullptr) {}
  ~MongoBatchFindRes() override;
  explicit PROTOBUF_CONSTEXPR MongoBatchFindRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoBatchFindRes(const MongoBatchFindRes& from);
  MongoBatchFindRes(MongoBatchFindRes&& from) noexcept
    : MongoBatchFindRes() {
    *this = ::std::move(from);
  }

  inline MongoBatchFindRes& operator=(const MongoBatchFindRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoBatchFindRes& operator=(MongoBatchFindRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoBatchFindRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoBatchFindRes* internal_default_instance() {
    return reinterpret_cast<const MongoBatchFindRes*>(
               &_MongoBatchFindRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MongoBatchFindRes& a, MongoBatchFindRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoBatchFindRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoBatchFindRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoBatchFindRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoBatchFindRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoBatchFindRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoBatchFindRes& from) {
    MongoBatchFindRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoBatchFindRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoBatchFindRes";
  }
  protected:
  explicit MongoBatchFindRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 3,
    kUserDataFieldNumber = 4,
    kSucceedFieldNumber = 1,
    kHasMoreFieldNumber = 2,
  };
  // repeated .DB.ProtoBsonObj data_list = 3;
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;
  public:
  void clear_data_list();
  ::DB::ProtoBsonObj* mutable_data_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >*
      mutable_data_list();
  private:
  const ::DB::ProtoBsonObj& _internal_data_list(int index) const;
  ::DB::ProtoBsonObj* _internal_add_data_list();
  public:
  const ::DB::ProtoBsonObj& data_list(int index) const;
  ::DB::ProtoBsonObj* add_data_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >&
      data_list() const;

  // .DB.MongoUserData user_data = 4;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::DB::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::DB::MongoUserData* release_user_data();
  ::DB::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::DB::MongoUserData* user_data);
  private:
  const ::DB::MongoUserData& _internal_user_data() const;
  ::DB::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::DB::MongoUserData* user_data);
  ::DB::MongoUserData* unsafe_arena_release_user_data();

  // bool succeed = 1;
  void clear_succeed();
  bool succeed() const;
  void set_succeed(bool value);
  private:
  bool _internal_succeed() const;
  void _internal_set_succeed(bool value);
  public:

  // bool has_more = 2;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoBatchFindRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj > data_list_;
    ::DB::MongoUserData* user_data_;
    bool succeed_;
    bool has_more_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoDBMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DB.MongoDBMsg) */ {
 public:
  inline MongoDBMsg() : MongoDBMsg(nullptr) {}
  ~MongoDBMsg() override;
  explicit PROTOBUF_CONSTEXPR MongoDBMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoDBMsg(const MongoDBMsg& from);
  MongoDBMsg(MongoDBMsg&& from) noexcept
    : MongoDBMsg() {
    *this = ::std::move(from);
  }

  inline MongoDBMsg& operator=(const MongoDBMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoDBMsg& operator=(MongoDBMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoDBMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoDBMsg* internal_default_instance() {
    return reinterpret_cast<const MongoDBMsg*>(
               &_MongoDBMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MongoDBMsg& a, MongoDBMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoDBMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoDBMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoDBMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoDBMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoDBMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoDBMsg& from) {
    MongoDBMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoDBMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DB.MongoDBMsg";
  }
  protected:
  explicit MongoDBMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInsertReqFieldNumber = 2,
    kInsertResFieldNumber = 3,
    kRemoveReqFieldNumber = 4,
    kRemoveResFieldNumber = 5,
    kSaveReqFieldNumber = 6,
    kSaveResFieldNumber = 7,
    kUpdateReqFieldNumber = 8,
    kUpdateResFieldNumber = 9,
    kFindReqFieldNumber = 10,
    kFindResFieldNumber = 11,
    kBatchFindReqFieldNumber = 12,
    kBatchFindResFieldNumber = 13,
    kCmdTypeFieldNumber = 1,
  };
  // .DB.MongoInsertReq insert_req = 2;
  bool has_insert_req() const;
  private:
  bool _internal_has_insert_req() const;
  public:
  void clear_insert_req();
  const ::DB::MongoInsertReq& insert_req() const;
  PROTOBUF_NODISCARD ::DB::MongoInsertReq* release_insert_req();
  ::DB::MongoInsertReq* mutable_insert_req();
  void set_allocated_insert_req(::DB::MongoInsertReq* insert_req);
  private:
  const ::DB::MongoInsertReq& _internal_insert_req() const;
  ::DB::MongoInsertReq* _internal_mutable_insert_req();
  public:
  void unsafe_arena_set_allocated_insert_req(
      ::DB::MongoInsertReq* insert_req);
  ::DB::MongoInsertReq* unsafe_arena_release_insert_req();

  // .DB.MongoInsertRes insert_res = 3;
  bool has_insert_res() const;
  private:
  bool _internal_has_insert_res() const;
  public:
  void clear_insert_res();
  const ::DB::MongoInsertRes& insert_res() const;
  PROTOBUF_NODISCARD ::DB::MongoInsertRes* release_insert_res();
  ::DB::MongoInsertRes* mutable_insert_res();
  void set_allocated_insert_res(::DB::MongoInsertRes* insert_res);
  private:
  const ::DB::MongoInsertRes& _internal_insert_res() const;
  ::DB::MongoInsertRes* _internal_mutable_insert_res();
  public:
  void unsafe_arena_set_allocated_insert_res(
      ::DB::MongoInsertRes* insert_res);
  ::DB::MongoInsertRes* unsafe_arena_release_insert_res();

  // .DB.MongoRemoveReq remove_req = 4;
  bool has_remove_req() const;
  private:
  bool _internal_has_remove_req() const;
  public:
  void clear_remove_req();
  const ::DB::MongoRemoveReq& remove_req() const;
  PROTOBUF_NODISCARD ::DB::MongoRemoveReq* release_remove_req();
  ::DB::MongoRemoveReq* mutable_remove_req();
  void set_allocated_remove_req(::DB::MongoRemoveReq* remove_req);
  private:
  const ::DB::MongoRemoveReq& _internal_remove_req() const;
  ::DB::MongoRemoveReq* _internal_mutable_remove_req();
  public:
  void unsafe_arena_set_allocated_remove_req(
      ::DB::MongoRemoveReq* remove_req);
  ::DB::MongoRemoveReq* unsafe_arena_release_remove_req();

  // .DB.MongoRemoveRes remove_res = 5;
  bool has_remove_res() const;
  private:
  bool _internal_has_remove_res() const;
  public:
  void clear_remove_res();
  const ::DB::MongoRemoveRes& remove_res() const;
  PROTOBUF_NODISCARD ::DB::MongoRemoveRes* release_remove_res();
  ::DB::MongoRemoveRes* mutable_remove_res();
  void set_allocated_remove_res(::DB::MongoRemoveRes* remove_res);
  private:
  const ::DB::MongoRemoveRes& _internal_remove_res() const;
  ::DB::MongoRemoveRes* _internal_mutable_remove_res();
  public:
  void unsafe_arena_set_allocated_remove_res(
      ::DB::MongoRemoveRes* remove_res);
  ::DB::MongoRemoveRes* unsafe_arena_release_remove_res();

  // .DB.MongoSaveReq save_req = 6;
  bool has_save_req() const;
  private:
  bool _internal_has_save_req() const;
  public:
  void clear_save_req();
  const ::DB::MongoSaveReq& save_req() const;
  PROTOBUF_NODISCARD ::DB::MongoSaveReq* release_save_req();
  ::DB::MongoSaveReq* mutable_save_req();
  void set_allocated_save_req(::DB::MongoSaveReq* save_req);
  private:
  const ::DB::MongoSaveReq& _internal_save_req() const;
  ::DB::MongoSaveReq* _internal_mutable_save_req();
  public:
  void unsafe_arena_set_allocated_save_req(
      ::DB::MongoSaveReq* save_req);
  ::DB::MongoSaveReq* unsafe_arena_release_save_req();

  // .DB.MongoSaveRes save_res = 7;
  bool has_save_res() const;
  private:
  bool _internal_has_save_res() const;
  public:
  void clear_save_res();
  const ::DB::MongoSaveRes& save_res() const;
  PROTOBUF_NODISCARD ::DB::MongoSaveRes* release_save_res();
  ::DB::MongoSaveRes* mutable_save_res();
  void set_allocated_save_res(::DB::MongoSaveRes* save_res);
  private:
  const ::DB::MongoSaveRes& _internal_save_res() const;
  ::DB::MongoSaveRes* _internal_mutable_save_res();
  public:
  void unsafe_arena_set_allocated_save_res(
      ::DB::MongoSaveRes* save_res);
  ::DB::MongoSaveRes* unsafe_arena_release_save_res();

  // .DB.MongoUpdateReq update_req = 8;
  bool has_update_req() const;
  private:
  bool _internal_has_update_req() const;
  public:
  void clear_update_req();
  const ::DB::MongoUpdateReq& update_req() const;
  PROTOBUF_NODISCARD ::DB::MongoUpdateReq* release_update_req();
  ::DB::MongoUpdateReq* mutable_update_req();
  void set_allocated_update_req(::DB::MongoUpdateReq* update_req);
  private:
  const ::DB::MongoUpdateReq& _internal_update_req() const;
  ::DB::MongoUpdateReq* _internal_mutable_update_req();
  public:
  void unsafe_arena_set_allocated_update_req(
      ::DB::MongoUpdateReq* update_req);
  ::DB::MongoUpdateReq* unsafe_arena_release_update_req();

  // .DB.MongoUpdateRes update_res = 9;
  bool has_update_res() const;
  private:
  bool _internal_has_update_res() const;
  public:
  void clear_update_res();
  const ::DB::MongoUpdateRes& update_res() const;
  PROTOBUF_NODISCARD ::DB::MongoUpdateRes* release_update_res();
  ::DB::MongoUpdateRes* mutable_update_res();
  void set_allocated_update_res(::DB::MongoUpdateRes* update_res);
  private:
  const ::DB::MongoUpdateRes& _internal_update_res() const;
  ::DB::MongoUpdateRes* _internal_mutable_update_res();
  public:
  void unsafe_arena_set_allocated_update_res(
      ::DB::MongoUpdateRes* update_res);
  ::DB::MongoUpdateRes* unsafe_arena_release_update_res();

  // .DB.MongoFindReq find_req = 10;
  bool has_find_req() const;
  private:
  bool _internal_has_find_req() const;
  public:
  void clear_find_req();
  const ::DB::MongoFindReq& find_req() const;
  PROTOBUF_NODISCARD ::DB::MongoFindReq* release_find_req();
  ::DB::MongoFindReq* mutable_find_req();
  void set_allocated_find_req(::DB::MongoFindReq* find_req);
  private:
  const ::DB::MongoFindReq& _internal_find_req() const;
  ::DB::MongoFindReq* _internal_mutable_find_req();
  public:
  void unsafe_arena_set_allocated_find_req(
      ::DB::MongoFindReq* find_req);
  ::DB::MongoFindReq* unsafe_arena_release_find_req();

  // .DB.MongoFindRes find_res = 11;
  bool has_find_res() const;
  private:
  bool _internal_has_find_res() const;
  public:
  void clear_find_res();
  const ::DB::MongoFindRes& find_res() const;
  PROTOBUF_NODISCARD ::DB::MongoFindRes* release_find_res();
  ::DB::MongoFindRes* mutable_find_res();
  void set_allocated_find_res(::DB::MongoFindRes* find_res);
  private:
  const ::DB::MongoFindRes& _internal_find_res() const;
  ::DB::MongoFindRes* _internal_mutable_find_res();
  public:
  void unsafe_arena_set_allocated_find_res(
      ::DB::MongoFindRes* find_res);
  ::DB::MongoFindRes* unsafe_arena_release_find_res();

  // .DB.MongoBatchFindReq batch_find_req = 12;
  bool has_batch_find_req() const;
  private:
  bool _internal_has_batch_find_req() const;
  public:
  void clear_batch_find_req();
  const ::DB::MongoBatchFindReq& batch_find_req() const;
  PROTOBUF_NODISCARD ::DB::MongoBatchFindReq* release_batch_find_req();
  ::DB::MongoBatchFindReq* mutable_batch_find_req();
  void set_allocated_batch_find_req(::DB::MongoBatchFindReq* batch_find_req);
  private:
  const ::DB::MongoBatchFindReq& _internal_batch_find_req() const;
  ::DB::MongoBatchFindReq* _internal_mutable_batch_find_req();
  public:
  void unsafe_arena_set_allocated_batch_find_req(
      ::DB::MongoBatchFindReq* batch_find_req);
  ::DB::MongoBatchFindReq* unsafe_arena_release_batch_find_req();

  // .DB.MongoBatchFindRes batch_find_res = 13;
  bool has_batch_find_res() const;
  private:
  bool _internal_has_batch_find_res() const;
  public:
  void clear_batch_find_res();
  const ::DB::MongoBatchFindRes& batch_find_res() const;
  PROTOBUF_NODISCARD ::DB::MongoBatchFindRes* release_batch_find_res();
  ::DB::MongoBatchFindRes* mutable_batch_find_res();
  void set_allocated_batch_find_res(::DB::MongoBatchFindRes* batch_find_res);
  private:
  const ::DB::MongoBatchFindRes& _internal_batch_find_res() const;
  ::DB::MongoBatchFindRes* _internal_mutable_batch_find_res();
  public:
  void unsafe_arena_set_allocated_batch_find_res(
      ::DB::MongoBatchFindRes* batch_find_res);
  ::DB::MongoBatchFindRes* unsafe_arena_release_batch_find_res();

  // int32 cmd_type = 1;
  void clear_cmd_type();
  int32_t cmd_type() const;
  void set_cmd_type(int32_t value);
  private:
  int32_t _internal_cmd_type() const;
  void _internal_set_cmd_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DB.MongoDBMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::DB::MongoInsertReq* insert_req_;
    ::DB::MongoInsertRes* insert_res_;
    ::DB::MongoRemoveReq* remove_req_;
    ::DB::MongoRemoveRes* remove_res_;
    ::DB::MongoSaveReq* save_req_;
    ::DB::MongoSaveRes* save_res_;
    ::DB::MongoUpdateReq* update_req_;
    ::DB::MongoUpdateRes* update_res_;
    ::DB::MongoFindReq* find_req_;
    ::DB::MongoFindRes* find_res_;
    ::DB::MongoBatchFindReq* batch_find_req_;
    ::DB::MongoBatchFindRes* batch_find_res_;
    int32_t cmd_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtoBsonData

// string key = 1;
inline void ProtoBsonData::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProtoBsonData::key() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonData::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.key)
}
inline std::string* ProtoBsonData::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:DB.ProtoBsonData.key)
  return _s;
}
inline const std::string& ProtoBsonData::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ProtoBsonData::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonData::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonData::release_key() {
  // @@protoc_insertion_point(field_release:DB.ProtoBsonData.key)
  return _impl_.key_.Release();
}
inline void ProtoBsonData::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.ProtoBsonData.key)
}

// int32 data_type = 2;
inline void ProtoBsonData::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline int32_t ProtoBsonData::_internal_data_type() const {
  return _impl_.data_type_;
}
inline int32_t ProtoBsonData::data_type() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.data_type)
  return _internal_data_type();
}
inline void ProtoBsonData::_internal_set_data_type(int32_t value) {
  
  _impl_.data_type_ = value;
}
inline void ProtoBsonData::set_data_type(int32_t value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.data_type)
}

// int32 var_int32 = 3;
inline void ProtoBsonData::clear_var_int32() {
  _impl_.var_int32_ = 0;
}
inline int32_t ProtoBsonData::_internal_var_int32() const {
  return _impl_.var_int32_;
}
inline int32_t ProtoBsonData::var_int32() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.var_int32)
  return _internal_var_int32();
}
inline void ProtoBsonData::_internal_set_var_int32(int32_t value) {
  
  _impl_.var_int32_ = value;
}
inline void ProtoBsonData::set_var_int32(int32_t value) {
  _internal_set_var_int32(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.var_int32)
}

// int64 var_int64 = 4;
inline void ProtoBsonData::clear_var_int64() {
  _impl_.var_int64_ = int64_t{0};
}
inline int64_t ProtoBsonData::_internal_var_int64() const {
  return _impl_.var_int64_;
}
inline int64_t ProtoBsonData::var_int64() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.var_int64)
  return _internal_var_int64();
}
inline void ProtoBsonData::_internal_set_var_int64(int64_t value) {
  
  _impl_.var_int64_ = value;
}
inline void ProtoBsonData::set_var_int64(int64_t value) {
  _internal_set_var_int64(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.var_int64)
}

// double var_double = 5;
inline void ProtoBsonData::clear_var_double() {
  _impl_.var_double_ = 0;
}
inline double ProtoBsonData::_internal_var_double() const {
  return _impl_.var_double_;
}
inline double ProtoBsonData::var_double() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.var_double)
  return _internal_var_double();
}
inline void ProtoBsonData::_internal_set_var_double(double value) {
  
  _impl_.var_double_ = value;
}
inline void ProtoBsonData::set_var_double(double value) {
  _internal_set_var_double(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.var_double)
}

// bool var_bool = 6;
inline void ProtoBsonData::clear_var_bool() {
  _impl_.var_bool_ = false;
}
inline bool ProtoBsonData::_internal_var_bool() const {
  return _impl_.var_bool_;
}
inline bool ProtoBsonData::var_bool() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.var_bool)
  return _internal_var_bool();
}
inline void ProtoBsonData::_internal_set_var_bool(bool value) {
  
  _impl_.var_bool_ = value;
}
inline void ProtoBsonData::set_var_bool(bool value) {
  _internal_set_var_bool(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.var_bool)
}

// string var_string = 7;
inline void ProtoBsonData::clear_var_string() {
  _impl_.var_string_.ClearToEmpty();
}
inline const std::string& ProtoBsonData::var_string() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.var_string)
  return _internal_var_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonData::set_var_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.var_string)
}
inline std::string* ProtoBsonData::mutable_var_string() {
  std::string* _s = _internal_mutable_var_string();
  // @@protoc_insertion_point(field_mutable:DB.ProtoBsonData.var_string)
  return _s;
}
inline const std::string& ProtoBsonData::_internal_var_string() const {
  return _impl_.var_string_.Get();
}
inline void ProtoBsonData::_internal_set_var_string(const std::string& value) {
  
  _impl_.var_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonData::_internal_mutable_var_string() {
  
  return _impl_.var_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonData::release_var_string() {
  // @@protoc_insertion_point(field_release:DB.ProtoBsonData.var_string)
  return _impl_.var_string_.Release();
}
inline void ProtoBsonData::set_allocated_var_string(std::string* var_string) {
  if (var_string != nullptr) {
    
  } else {
    
  }
  _impl_.var_string_.SetAllocated(var_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_string_.IsDefault()) {
    _impl_.var_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.ProtoBsonData.var_string)
}

// bytes var_bin = 8;
inline void ProtoBsonData::clear_var_bin() {
  _impl_.var_bin_.ClearToEmpty();
}
inline const std::string& ProtoBsonData::var_bin() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonData.var_bin)
  return _internal_var_bin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonData::set_var_bin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_bin_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.ProtoBsonData.var_bin)
}
inline std::string* ProtoBsonData::mutable_var_bin() {
  std::string* _s = _internal_mutable_var_bin();
  // @@protoc_insertion_point(field_mutable:DB.ProtoBsonData.var_bin)
  return _s;
}
inline const std::string& ProtoBsonData::_internal_var_bin() const {
  return _impl_.var_bin_.Get();
}
inline void ProtoBsonData::_internal_set_var_bin(const std::string& value) {
  
  _impl_.var_bin_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonData::_internal_mutable_var_bin() {
  
  return _impl_.var_bin_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonData::release_var_bin() {
  // @@protoc_insertion_point(field_release:DB.ProtoBsonData.var_bin)
  return _impl_.var_bin_.Release();
}
inline void ProtoBsonData::set_allocated_var_bin(std::string* var_bin) {
  if (var_bin != nullptr) {
    
  } else {
    
  }
  _impl_.var_bin_.SetAllocated(var_bin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_bin_.IsDefault()) {
    _impl_.var_bin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.ProtoBsonData.var_bin)
}

// -------------------------------------------------------------------

// ProtoBsonObj

// repeated .DB.ProtoBsonData bson_data_list = 1;
inline int ProtoBsonObj::_internal_bson_data_list_size() const {
  return _impl_.bson_data_list_.size();
}
inline int ProtoBsonObj::bson_data_list_size() const {
  return _internal_bson_data_list_size();
}
inline void ProtoBsonObj::clear_bson_data_list() {
  _impl_.bson_data_list_.Clear();
}
inline ::DB::ProtoBsonData* ProtoBsonObj::mutable_bson_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:DB.ProtoBsonObj.bson_data_list)
  return _impl_.bson_data_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonData >*
ProtoBsonObj::mutable_bson_data_list() {
  // @@protoc_insertion_point(field_mutable_list:DB.ProtoBsonObj.bson_data_list)
  return &_impl_.bson_data_list_;
}
inline const ::DB::ProtoBsonData& ProtoBsonObj::_internal_bson_data_list(int index) const {
  return _impl_.bson_data_list_.Get(index);
}
inline const ::DB::ProtoBsonData& ProtoBsonObj::bson_data_list(int index) const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonObj.bson_data_list)
  return _internal_bson_data_list(index);
}
inline ::DB::ProtoBsonData* ProtoBsonObj::_internal_add_bson_data_list() {
  return _impl_.bson_data_list_.Add();
}
inline ::DB::ProtoBsonData* ProtoBsonObj::add_bson_data_list() {
  ::DB::ProtoBsonData* _add = _internal_add_bson_data_list();
  // @@protoc_insertion_point(field_add:DB.ProtoBsonObj.bson_data_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonData >&
ProtoBsonObj::bson_data_list() const {
  // @@protoc_insertion_point(field_list:DB.ProtoBsonObj.bson_data_list)
  return _impl_.bson_data_list_;
}

// -------------------------------------------------------------------

// MongoUserData

// int32 type = 1;
inline void MongoUserData::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t MongoUserData::_internal_type() const {
  return _impl_.type_;
}
inline int32_t MongoUserData::type() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.type)
  return _internal_type();
}
inline void MongoUserData::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void MongoUserData::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.type)
}

// uint64 trans_gid = 2;
inline void MongoUserData::clear_trans_gid() {
  _impl_.trans_gid_ = uint64_t{0u};
}
inline uint64_t MongoUserData::_internal_trans_gid() const {
  return _impl_.trans_gid_;
}
inline uint64_t MongoUserData::trans_gid() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.trans_gid)
  return _internal_trans_gid();
}
inline void MongoUserData::_internal_set_trans_gid(uint64_t value) {
  
  _impl_.trans_gid_ = value;
}
inline void MongoUserData::set_trans_gid(uint64_t value) {
  _internal_set_trans_gid(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.trans_gid)
}

// uint64 session_gid = 3;
inline void MongoUserData::clear_session_gid() {
  _impl_.session_gid_ = uint64_t{0u};
}
inline uint64_t MongoUserData::_internal_session_gid() const {
  return _impl_.session_gid_;
}
inline uint64_t MongoUserData::session_gid() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.session_gid)
  return _internal_session_gid();
}
inline void MongoUserData::_internal_set_session_gid(uint64_t value) {
  
  _impl_.session_gid_ = value;
}
inline void MongoUserData::set_session_gid(uint64_t value) {
  _internal_set_session_gid(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.session_gid)
}

// string account_id = 4;
inline void MongoUserData::clear_account_id() {
  _impl_.account_id_.ClearToEmpty();
}
inline const std::string& MongoUserData::account_id() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.account_id)
  return _internal_account_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUserData::set_account_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.account_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoUserData.account_id)
}
inline std::string* MongoUserData::mutable_account_id() {
  std::string* _s = _internal_mutable_account_id();
  // @@protoc_insertion_point(field_mutable:DB.MongoUserData.account_id)
  return _s;
}
inline const std::string& MongoUserData::_internal_account_id() const {
  return _impl_.account_id_.Get();
}
inline void MongoUserData::_internal_set_account_id(const std::string& value) {
  
  _impl_.account_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUserData::_internal_mutable_account_id() {
  
  return _impl_.account_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUserData::release_account_id() {
  // @@protoc_insertion_point(field_release:DB.MongoUserData.account_id)
  return _impl_.account_id_.Release();
}
inline void MongoUserData::set_allocated_account_id(std::string* account_id) {
  if (account_id != nullptr) {
    
  } else {
    
  }
  _impl_.account_id_.SetAllocated(account_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.account_id_.IsDefault()) {
    _impl_.account_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUserData.account_id)
}

// uint64 player_gid = 5;
inline void MongoUserData::clear_player_gid() {
  _impl_.player_gid_ = uint64_t{0u};
}
inline uint64_t MongoUserData::_internal_player_gid() const {
  return _impl_.player_gid_;
}
inline uint64_t MongoUserData::player_gid() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.player_gid)
  return _internal_player_gid();
}
inline void MongoUserData::_internal_set_player_gid(uint64_t value) {
  
  _impl_.player_gid_ = value;
}
inline void MongoUserData::set_player_gid(uint64_t value) {
  _internal_set_player_gid(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.player_gid)
}

// uint64 other_player_gid = 6;
inline void MongoUserData::clear_other_player_gid() {
  _impl_.other_player_gid_ = uint64_t{0u};
}
inline uint64_t MongoUserData::_internal_other_player_gid() const {
  return _impl_.other_player_gid_;
}
inline uint64_t MongoUserData::other_player_gid() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.other_player_gid)
  return _internal_other_player_gid();
}
inline void MongoUserData::_internal_set_other_player_gid(uint64_t value) {
  
  _impl_.other_player_gid_ = value;
}
inline void MongoUserData::set_other_player_gid(uint64_t value) {
  _internal_set_other_player_gid(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.other_player_gid)
}

// uint64 offline_msg_gid = 7;
inline void MongoUserData::clear_offline_msg_gid() {
  _impl_.offline_msg_gid_ = uint64_t{0u};
}
inline uint64_t MongoUserData::_internal_offline_msg_gid() const {
  return _impl_.offline_msg_gid_;
}
inline uint64_t MongoUserData::offline_msg_gid() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.offline_msg_gid)
  return _internal_offline_msg_gid();
}
inline void MongoUserData::_internal_set_offline_msg_gid(uint64_t value) {
  
  _impl_.offline_msg_gid_ = value;
}
inline void MongoUserData::set_offline_msg_gid(uint64_t value) {
  _internal_set_offline_msg_gid(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.offline_msg_gid)
}

// string sdk_user_id = 8;
inline void MongoUserData::clear_sdk_user_id() {
  _impl_.sdk_user_id_.ClearToEmpty();
}
inline const std::string& MongoUserData::sdk_user_id() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.sdk_user_id)
  return _internal_sdk_user_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUserData::set_sdk_user_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sdk_user_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoUserData.sdk_user_id)
}
inline std::string* MongoUserData::mutable_sdk_user_id() {
  std::string* _s = _internal_mutable_sdk_user_id();
  // @@protoc_insertion_point(field_mutable:DB.MongoUserData.sdk_user_id)
  return _s;
}
inline const std::string& MongoUserData::_internal_sdk_user_id() const {
  return _impl_.sdk_user_id_.Get();
}
inline void MongoUserData::_internal_set_sdk_user_id(const std::string& value) {
  
  _impl_.sdk_user_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUserData::_internal_mutable_sdk_user_id() {
  
  return _impl_.sdk_user_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUserData::release_sdk_user_id() {
  // @@protoc_insertion_point(field_release:DB.MongoUserData.sdk_user_id)
  return _impl_.sdk_user_id_.Release();
}
inline void MongoUserData::set_allocated_sdk_user_id(std::string* sdk_user_id) {
  if (sdk_user_id != nullptr) {
    
  } else {
    
  }
  _impl_.sdk_user_id_.SetAllocated(sdk_user_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sdk_user_id_.IsDefault()) {
    _impl_.sdk_user_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUserData.sdk_user_id)
}

// int32 svr_id = 9;
inline void MongoUserData::clear_svr_id() {
  _impl_.svr_id_ = 0;
}
inline int32_t MongoUserData::_internal_svr_id() const {
  return _impl_.svr_id_;
}
inline int32_t MongoUserData::svr_id() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.svr_id)
  return _internal_svr_id();
}
inline void MongoUserData::_internal_set_svr_id(int32_t value) {
  
  _impl_.svr_id_ = value;
}
inline void MongoUserData::set_svr_id(int32_t value) {
  _internal_set_svr_id(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.svr_id)
}

// int32 int_var1 = 10;
inline void MongoUserData::clear_int_var1() {
  _impl_.int_var1_ = 0;
}
inline int32_t MongoUserData::_internal_int_var1() const {
  return _impl_.int_var1_;
}
inline int32_t MongoUserData::int_var1() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.int_var1)
  return _internal_int_var1();
}
inline void MongoUserData::_internal_set_int_var1(int32_t value) {
  
  _impl_.int_var1_ = value;
}
inline void MongoUserData::set_int_var1(int32_t value) {
  _internal_set_int_var1(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.int_var1)
}

// int32 int_var2 = 11;
inline void MongoUserData::clear_int_var2() {
  _impl_.int_var2_ = 0;
}
inline int32_t MongoUserData::_internal_int_var2() const {
  return _impl_.int_var2_;
}
inline int32_t MongoUserData::int_var2() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.int_var2)
  return _internal_int_var2();
}
inline void MongoUserData::_internal_set_int_var2(int32_t value) {
  
  _impl_.int_var2_ = value;
}
inline void MongoUserData::set_int_var2(int32_t value) {
  _internal_set_int_var2(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.int_var2)
}

// int32 int_var3 = 12;
inline void MongoUserData::clear_int_var3() {
  _impl_.int_var3_ = 0;
}
inline int32_t MongoUserData::_internal_int_var3() const {
  return _impl_.int_var3_;
}
inline int32_t MongoUserData::int_var3() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.int_var3)
  return _internal_int_var3();
}
inline void MongoUserData::_internal_set_int_var3(int32_t value) {
  
  _impl_.int_var3_ = value;
}
inline void MongoUserData::set_int_var3(int32_t value) {
  _internal_set_int_var3(value);
  // @@protoc_insertion_point(field_set:DB.MongoUserData.int_var3)
}

// string str_var1 = 13;
inline void MongoUserData::clear_str_var1() {
  _impl_.str_var1_.ClearToEmpty();
}
inline const std::string& MongoUserData::str_var1() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.str_var1)
  return _internal_str_var1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUserData::set_str_var1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.str_var1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoUserData.str_var1)
}
inline std::string* MongoUserData::mutable_str_var1() {
  std::string* _s = _internal_mutable_str_var1();
  // @@protoc_insertion_point(field_mutable:DB.MongoUserData.str_var1)
  return _s;
}
inline const std::string& MongoUserData::_internal_str_var1() const {
  return _impl_.str_var1_.Get();
}
inline void MongoUserData::_internal_set_str_var1(const std::string& value) {
  
  _impl_.str_var1_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUserData::_internal_mutable_str_var1() {
  
  return _impl_.str_var1_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUserData::release_str_var1() {
  // @@protoc_insertion_point(field_release:DB.MongoUserData.str_var1)
  return _impl_.str_var1_.Release();
}
inline void MongoUserData::set_allocated_str_var1(std::string* str_var1) {
  if (str_var1 != nullptr) {
    
  } else {
    
  }
  _impl_.str_var1_.SetAllocated(str_var1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_var1_.IsDefault()) {
    _impl_.str_var1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUserData.str_var1)
}

// string str_var2 = 14;
inline void MongoUserData::clear_str_var2() {
  _impl_.str_var2_.ClearToEmpty();
}
inline const std::string& MongoUserData::str_var2() const {
  // @@protoc_insertion_point(field_get:DB.MongoUserData.str_var2)
  return _internal_str_var2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUserData::set_str_var2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.str_var2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoUserData.str_var2)
}
inline std::string* MongoUserData::mutable_str_var2() {
  std::string* _s = _internal_mutable_str_var2();
  // @@protoc_insertion_point(field_mutable:DB.MongoUserData.str_var2)
  return _s;
}
inline const std::string& MongoUserData::_internal_str_var2() const {
  return _impl_.str_var2_.Get();
}
inline void MongoUserData::_internal_set_str_var2(const std::string& value) {
  
  _impl_.str_var2_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUserData::_internal_mutable_str_var2() {
  
  return _impl_.str_var2_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUserData::release_str_var2() {
  // @@protoc_insertion_point(field_release:DB.MongoUserData.str_var2)
  return _impl_.str_var2_.Release();
}
inline void MongoUserData::set_allocated_str_var2(std::string* str_var2) {
  if (str_var2 != nullptr) {
    
  } else {
    
  }
  _impl_.str_var2_.SetAllocated(str_var2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_var2_.IsDefault()) {
    _impl_.str_var2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUserData.str_var2)
}

// -------------------------------------------------------------------

// MongoInsertReq

// string db_name = 1;
inline void MongoInsertReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoInsertReq::db_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoInsertReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoInsertReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoInsertReq.db_name)
}
inline std::string* MongoInsertReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoInsertReq.db_name)
  return _s;
}
inline const std::string& MongoInsertReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoInsertReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoInsertReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoInsertReq::release_db_name() {
  // @@protoc_insertion_point(field_release:DB.MongoInsertReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoInsertReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoInsertReq.db_name)
}

// string col_name = 2;
inline void MongoInsertReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoInsertReq::col_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoInsertReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoInsertReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoInsertReq.col_name)
}
inline std::string* MongoInsertReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoInsertReq.col_name)
  return _s;
}
inline const std::string& MongoInsertReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoInsertReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoInsertReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoInsertReq::release_col_name() {
  // @@protoc_insertion_point(field_release:DB.MongoInsertReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoInsertReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoInsertReq.col_name)
}

// .DB.ProtoBsonObj doc = 3;
inline bool MongoInsertReq::_internal_has_doc() const {
  return this != internal_default_instance() && _impl_.doc_ != nullptr;
}
inline bool MongoInsertReq::has_doc() const {
  return _internal_has_doc();
}
inline void MongoInsertReq::clear_doc() {
  if (GetArenaForAllocation() == nullptr && _impl_.doc_ != nullptr) {
    delete _impl_.doc_;
  }
  _impl_.doc_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoInsertReq::_internal_doc() const {
  const ::DB::ProtoBsonObj* p = _impl_.doc_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoInsertReq::doc() const {
  // @@protoc_insertion_point(field_get:DB.MongoInsertReq.doc)
  return _internal_doc();
}
inline void MongoInsertReq::unsafe_arena_set_allocated_doc(
    ::DB::ProtoBsonObj* doc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.doc_);
  }
  _impl_.doc_ = doc;
  if (doc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoInsertReq.doc)
}
inline ::DB::ProtoBsonObj* MongoInsertReq::release_doc() {
  
  ::DB::ProtoBsonObj* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoInsertReq::unsafe_arena_release_doc() {
  // @@protoc_insertion_point(field_release:DB.MongoInsertReq.doc)
  
  ::DB::ProtoBsonObj* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoInsertReq::_internal_mutable_doc() {
  
  if (_impl_.doc_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.doc_ = p;
  }
  return _impl_.doc_;
}
inline ::DB::ProtoBsonObj* MongoInsertReq::mutable_doc() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_doc();
  // @@protoc_insertion_point(field_mutable:DB.MongoInsertReq.doc)
  return _msg;
}
inline void MongoInsertReq::set_allocated_doc(::DB::ProtoBsonObj* doc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.doc_;
  }
  if (doc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(doc);
    if (message_arena != submessage_arena) {
      doc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.doc_ = doc;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoInsertReq.doc)
}

// .DB.MongoUserData user_data = 4;
inline bool MongoInsertReq::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoInsertReq::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoInsertReq::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoInsertReq::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoInsertReq::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoInsertReq.user_data)
  return _internal_user_data();
}
inline void MongoInsertReq::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoInsertReq.user_data)
}
inline ::DB::MongoUserData* MongoInsertReq::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoInsertReq::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoInsertReq.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoInsertReq::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoInsertReq::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoInsertReq.user_data)
  return _msg;
}
inline void MongoInsertReq::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoInsertReq.user_data)
}

// -------------------------------------------------------------------

// MongoInsertRes

// bool succeed = 1;
inline void MongoInsertRes::clear_succeed() {
  _impl_.succeed_ = false;
}
inline bool MongoInsertRes::_internal_succeed() const {
  return _impl_.succeed_;
}
inline bool MongoInsertRes::succeed() const {
  // @@protoc_insertion_point(field_get:DB.MongoInsertRes.succeed)
  return _internal_succeed();
}
inline void MongoInsertRes::_internal_set_succeed(bool value) {
  
  _impl_.succeed_ = value;
}
inline void MongoInsertRes::set_succeed(bool value) {
  _internal_set_succeed(value);
  // @@protoc_insertion_point(field_set:DB.MongoInsertRes.succeed)
}

// .DB.MongoUserData user_data = 2;
inline bool MongoInsertRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoInsertRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoInsertRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoInsertRes::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoInsertRes::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoInsertRes.user_data)
  return _internal_user_data();
}
inline void MongoInsertRes::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoInsertRes.user_data)
}
inline ::DB::MongoUserData* MongoInsertRes::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoInsertRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoInsertRes.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoInsertRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoInsertRes::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoInsertRes.user_data)
  return _msg;
}
inline void MongoInsertRes::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoInsertRes.user_data)
}

// -------------------------------------------------------------------

// MongoRemoveReq

// string db_name = 1;
inline void MongoRemoveReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoRemoveReq::db_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoRemoveReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoRemoveReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoRemoveReq.db_name)
}
inline std::string* MongoRemoveReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoRemoveReq.db_name)
  return _s;
}
inline const std::string& MongoRemoveReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoRemoveReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::release_db_name() {
  // @@protoc_insertion_point(field_release:DB.MongoRemoveReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoRemoveReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoRemoveReq.db_name)
}

// string col_name = 2;
inline void MongoRemoveReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoRemoveReq::col_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoRemoveReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoRemoveReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoRemoveReq.col_name)
}
inline std::string* MongoRemoveReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoRemoveReq.col_name)
  return _s;
}
inline const std::string& MongoRemoveReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoRemoveReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::release_col_name() {
  // @@protoc_insertion_point(field_release:DB.MongoRemoveReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoRemoveReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoRemoveReq.col_name)
}

// .DB.ProtoBsonObj selector = 3;
inline bool MongoRemoveReq::_internal_has_selector() const {
  return this != internal_default_instance() && _impl_.selector_ != nullptr;
}
inline bool MongoRemoveReq::has_selector() const {
  return _internal_has_selector();
}
inline void MongoRemoveReq::clear_selector() {
  if (GetArenaForAllocation() == nullptr && _impl_.selector_ != nullptr) {
    delete _impl_.selector_;
  }
  _impl_.selector_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoRemoveReq::_internal_selector() const {
  const ::DB::ProtoBsonObj* p = _impl_.selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoRemoveReq::selector() const {
  // @@protoc_insertion_point(field_get:DB.MongoRemoveReq.selector)
  return _internal_selector();
}
inline void MongoRemoveReq::unsafe_arena_set_allocated_selector(
    ::DB::ProtoBsonObj* selector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selector_);
  }
  _impl_.selector_ = selector;
  if (selector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoRemoveReq.selector)
}
inline ::DB::ProtoBsonObj* MongoRemoveReq::release_selector() {
  
  ::DB::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoRemoveReq::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_release:DB.MongoRemoveReq.selector)
  
  ::DB::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoRemoveReq::_internal_mutable_selector() {
  
  if (_impl_.selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.selector_ = p;
  }
  return _impl_.selector_;
}
inline ::DB::ProtoBsonObj* MongoRemoveReq::mutable_selector() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:DB.MongoRemoveReq.selector)
  return _msg;
}
inline void MongoRemoveReq::set_allocated_selector(::DB::ProtoBsonObj* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selector_;
  }
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.selector_ = selector;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoRemoveReq.selector)
}

// .DB.MongoUserData user_data = 4;
inline bool MongoRemoveReq::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoRemoveReq::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoRemoveReq::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoRemoveReq::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoRemoveReq::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoRemoveReq.user_data)
  return _internal_user_data();
}
inline void MongoRemoveReq::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoRemoveReq.user_data)
}
inline ::DB::MongoUserData* MongoRemoveReq::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoRemoveReq::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoRemoveReq.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoRemoveReq::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoRemoveReq::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoRemoveReq.user_data)
  return _msg;
}
inline void MongoRemoveReq::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoRemoveReq.user_data)
}

// -------------------------------------------------------------------

// MongoRemoveRes

// bool succeed = 1;
inline void MongoRemoveRes::clear_succeed() {
  _impl_.succeed_ = false;
}
inline bool MongoRemoveRes::_internal_succeed() const {
  return _impl_.succeed_;
}
inline bool MongoRemoveRes::succeed() const {
  // @@protoc_insertion_point(field_get:DB.MongoRemoveRes.succeed)
  return _internal_succeed();
}
inline void MongoRemoveRes::_internal_set_succeed(bool value) {
  
  _impl_.succeed_ = value;
}
inline void MongoRemoveRes::set_succeed(bool value) {
  _internal_set_succeed(value);
  // @@protoc_insertion_point(field_set:DB.MongoRemoveRes.succeed)
}

// .DB.MongoUserData user_data = 2;
inline bool MongoRemoveRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoRemoveRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoRemoveRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoRemoveRes::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoRemoveRes::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoRemoveRes.user_data)
  return _internal_user_data();
}
inline void MongoRemoveRes::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoRemoveRes.user_data)
}
inline ::DB::MongoUserData* MongoRemoveRes::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoRemoveRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoRemoveRes.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoRemoveRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoRemoveRes::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoRemoveRes.user_data)
  return _msg;
}
inline void MongoRemoveRes::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoRemoveRes.user_data)
}

// -------------------------------------------------------------------

// MongoSaveReq

// string db_name = 1;
inline void MongoSaveReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoSaveReq::db_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoSaveReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoSaveReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoSaveReq.db_name)
}
inline std::string* MongoSaveReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoSaveReq.db_name)
  return _s;
}
inline const std::string& MongoSaveReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoSaveReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoSaveReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoSaveReq::release_db_name() {
  // @@protoc_insertion_point(field_release:DB.MongoSaveReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoSaveReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoSaveReq.db_name)
}

// string col_name = 2;
inline void MongoSaveReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoSaveReq::col_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoSaveReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoSaveReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoSaveReq.col_name)
}
inline std::string* MongoSaveReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoSaveReq.col_name)
  return _s;
}
inline const std::string& MongoSaveReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoSaveReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoSaveReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoSaveReq::release_col_name() {
  // @@protoc_insertion_point(field_release:DB.MongoSaveReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoSaveReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoSaveReq.col_name)
}

// .DB.ProtoBsonObj doc = 3;
inline bool MongoSaveReq::_internal_has_doc() const {
  return this != internal_default_instance() && _impl_.doc_ != nullptr;
}
inline bool MongoSaveReq::has_doc() const {
  return _internal_has_doc();
}
inline void MongoSaveReq::clear_doc() {
  if (GetArenaForAllocation() == nullptr && _impl_.doc_ != nullptr) {
    delete _impl_.doc_;
  }
  _impl_.doc_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoSaveReq::_internal_doc() const {
  const ::DB::ProtoBsonObj* p = _impl_.doc_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoSaveReq::doc() const {
  // @@protoc_insertion_point(field_get:DB.MongoSaveReq.doc)
  return _internal_doc();
}
inline void MongoSaveReq::unsafe_arena_set_allocated_doc(
    ::DB::ProtoBsonObj* doc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.doc_);
  }
  _impl_.doc_ = doc;
  if (doc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoSaveReq.doc)
}
inline ::DB::ProtoBsonObj* MongoSaveReq::release_doc() {
  
  ::DB::ProtoBsonObj* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoSaveReq::unsafe_arena_release_doc() {
  // @@protoc_insertion_point(field_release:DB.MongoSaveReq.doc)
  
  ::DB::ProtoBsonObj* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoSaveReq::_internal_mutable_doc() {
  
  if (_impl_.doc_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.doc_ = p;
  }
  return _impl_.doc_;
}
inline ::DB::ProtoBsonObj* MongoSaveReq::mutable_doc() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_doc();
  // @@protoc_insertion_point(field_mutable:DB.MongoSaveReq.doc)
  return _msg;
}
inline void MongoSaveReq::set_allocated_doc(::DB::ProtoBsonObj* doc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.doc_;
  }
  if (doc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(doc);
    if (message_arena != submessage_arena) {
      doc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.doc_ = doc;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoSaveReq.doc)
}

// .DB.MongoUserData user_data = 4;
inline bool MongoSaveReq::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoSaveReq::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoSaveReq::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoSaveReq::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoSaveReq::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoSaveReq.user_data)
  return _internal_user_data();
}
inline void MongoSaveReq::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoSaveReq.user_data)
}
inline ::DB::MongoUserData* MongoSaveReq::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoSaveReq::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoSaveReq.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoSaveReq::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoSaveReq::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoSaveReq.user_data)
  return _msg;
}
inline void MongoSaveReq::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoSaveReq.user_data)
}

// -------------------------------------------------------------------

// MongoSaveRes

// bool succeed = 1;
inline void MongoSaveRes::clear_succeed() {
  _impl_.succeed_ = false;
}
inline bool MongoSaveRes::_internal_succeed() const {
  return _impl_.succeed_;
}
inline bool MongoSaveRes::succeed() const {
  // @@protoc_insertion_point(field_get:DB.MongoSaveRes.succeed)
  return _internal_succeed();
}
inline void MongoSaveRes::_internal_set_succeed(bool value) {
  
  _impl_.succeed_ = value;
}
inline void MongoSaveRes::set_succeed(bool value) {
  _internal_set_succeed(value);
  // @@protoc_insertion_point(field_set:DB.MongoSaveRes.succeed)
}

// .DB.MongoUserData user_data = 2;
inline bool MongoSaveRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoSaveRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoSaveRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoSaveRes::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoSaveRes::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoSaveRes.user_data)
  return _internal_user_data();
}
inline void MongoSaveRes::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoSaveRes.user_data)
}
inline ::DB::MongoUserData* MongoSaveRes::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoSaveRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoSaveRes.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoSaveRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoSaveRes::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoSaveRes.user_data)
  return _msg;
}
inline void MongoSaveRes::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoSaveRes.user_data)
}

// -------------------------------------------------------------------

// MongoUpdateReq

// string db_name = 1;
inline void MongoUpdateReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoUpdateReq::db_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUpdateReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoUpdateReq.db_name)
}
inline std::string* MongoUpdateReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoUpdateReq.db_name)
  return _s;
}
inline const std::string& MongoUpdateReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoUpdateReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUpdateReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUpdateReq::release_db_name() {
  // @@protoc_insertion_point(field_release:DB.MongoUpdateReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoUpdateReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUpdateReq.db_name)
}

// string col_name = 2;
inline void MongoUpdateReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoUpdateReq::col_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUpdateReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoUpdateReq.col_name)
}
inline std::string* MongoUpdateReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoUpdateReq.col_name)
  return _s;
}
inline const std::string& MongoUpdateReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoUpdateReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUpdateReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUpdateReq::release_col_name() {
  // @@protoc_insertion_point(field_release:DB.MongoUpdateReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoUpdateReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUpdateReq.col_name)
}

// .DB.ProtoBsonObj selector = 3;
inline bool MongoUpdateReq::_internal_has_selector() const {
  return this != internal_default_instance() && _impl_.selector_ != nullptr;
}
inline bool MongoUpdateReq::has_selector() const {
  return _internal_has_selector();
}
inline void MongoUpdateReq::clear_selector() {
  if (GetArenaForAllocation() == nullptr && _impl_.selector_ != nullptr) {
    delete _impl_.selector_;
  }
  _impl_.selector_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoUpdateReq::_internal_selector() const {
  const ::DB::ProtoBsonObj* p = _impl_.selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoUpdateReq::selector() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateReq.selector)
  return _internal_selector();
}
inline void MongoUpdateReq::unsafe_arena_set_allocated_selector(
    ::DB::ProtoBsonObj* selector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selector_);
  }
  _impl_.selector_ = selector;
  if (selector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoUpdateReq.selector)
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::release_selector() {
  
  ::DB::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_release:DB.MongoUpdateReq.selector)
  
  ::DB::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::_internal_mutable_selector() {
  
  if (_impl_.selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.selector_ = p;
  }
  return _impl_.selector_;
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::mutable_selector() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:DB.MongoUpdateReq.selector)
  return _msg;
}
inline void MongoUpdateReq::set_allocated_selector(::DB::ProtoBsonObj* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selector_;
  }
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.selector_ = selector;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUpdateReq.selector)
}

// .DB.ProtoBsonObj updator = 4;
inline bool MongoUpdateReq::_internal_has_updator() const {
  return this != internal_default_instance() && _impl_.updator_ != nullptr;
}
inline bool MongoUpdateReq::has_updator() const {
  return _internal_has_updator();
}
inline void MongoUpdateReq::clear_updator() {
  if (GetArenaForAllocation() == nullptr && _impl_.updator_ != nullptr) {
    delete _impl_.updator_;
  }
  _impl_.updator_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoUpdateReq::_internal_updator() const {
  const ::DB::ProtoBsonObj* p = _impl_.updator_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoUpdateReq::updator() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateReq.updator)
  return _internal_updator();
}
inline void MongoUpdateReq::unsafe_arena_set_allocated_updator(
    ::DB::ProtoBsonObj* updator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updator_);
  }
  _impl_.updator_ = updator;
  if (updator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoUpdateReq.updator)
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::release_updator() {
  
  ::DB::ProtoBsonObj* temp = _impl_.updator_;
  _impl_.updator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::unsafe_arena_release_updator() {
  // @@protoc_insertion_point(field_release:DB.MongoUpdateReq.updator)
  
  ::DB::ProtoBsonObj* temp = _impl_.updator_;
  _impl_.updator_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::_internal_mutable_updator() {
  
  if (_impl_.updator_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.updator_ = p;
  }
  return _impl_.updator_;
}
inline ::DB::ProtoBsonObj* MongoUpdateReq::mutable_updator() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_updator();
  // @@protoc_insertion_point(field_mutable:DB.MongoUpdateReq.updator)
  return _msg;
}
inline void MongoUpdateReq::set_allocated_updator(::DB::ProtoBsonObj* updator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.updator_;
  }
  if (updator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(updator);
    if (message_arena != submessage_arena) {
      updator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updator, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updator_ = updator;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUpdateReq.updator)
}

// .DB.MongoUserData user_data = 5;
inline bool MongoUpdateReq::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoUpdateReq::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoUpdateReq::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoUpdateReq::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoUpdateReq::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateReq.user_data)
  return _internal_user_data();
}
inline void MongoUpdateReq::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoUpdateReq.user_data)
}
inline ::DB::MongoUserData* MongoUpdateReq::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoUpdateReq::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoUpdateReq.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoUpdateReq::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoUpdateReq::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoUpdateReq.user_data)
  return _msg;
}
inline void MongoUpdateReq::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUpdateReq.user_data)
}

// -------------------------------------------------------------------

// MongoUpdateRes

// bool succeed = 1;
inline void MongoUpdateRes::clear_succeed() {
  _impl_.succeed_ = false;
}
inline bool MongoUpdateRes::_internal_succeed() const {
  return _impl_.succeed_;
}
inline bool MongoUpdateRes::succeed() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateRes.succeed)
  return _internal_succeed();
}
inline void MongoUpdateRes::_internal_set_succeed(bool value) {
  
  _impl_.succeed_ = value;
}
inline void MongoUpdateRes::set_succeed(bool value) {
  _internal_set_succeed(value);
  // @@protoc_insertion_point(field_set:DB.MongoUpdateRes.succeed)
}

// .DB.MongoUserData user_data = 2;
inline bool MongoUpdateRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoUpdateRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoUpdateRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoUpdateRes::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoUpdateRes::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoUpdateRes.user_data)
  return _internal_user_data();
}
inline void MongoUpdateRes::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoUpdateRes.user_data)
}
inline ::DB::MongoUserData* MongoUpdateRes::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoUpdateRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoUpdateRes.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoUpdateRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoUpdateRes::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoUpdateRes.user_data)
  return _msg;
}
inline void MongoUpdateRes::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoUpdateRes.user_data)
}

// -------------------------------------------------------------------

// MongoFindReq

// string db_name = 1;
inline void MongoFindReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoFindReq::db_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoFindReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoFindReq.db_name)
}
inline std::string* MongoFindReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoFindReq.db_name)
  return _s;
}
inline const std::string& MongoFindReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoFindReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoFindReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoFindReq::release_db_name() {
  // @@protoc_insertion_point(field_release:DB.MongoFindReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoFindReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoFindReq.db_name)
}

// string col_name = 2;
inline void MongoFindReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoFindReq::col_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoFindReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoFindReq.col_name)
}
inline std::string* MongoFindReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoFindReq.col_name)
  return _s;
}
inline const std::string& MongoFindReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoFindReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoFindReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoFindReq::release_col_name() {
  // @@protoc_insertion_point(field_release:DB.MongoFindReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoFindReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoFindReq.col_name)
}

// .DB.ProtoBsonObj query = 3;
inline bool MongoFindReq::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool MongoFindReq::has_query() const {
  return _internal_has_query();
}
inline void MongoFindReq::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoFindReq::_internal_query() const {
  const ::DB::ProtoBsonObj* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoFindReq::query() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.query)
  return _internal_query();
}
inline void MongoFindReq::unsafe_arena_set_allocated_query(
    ::DB::ProtoBsonObj* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoFindReq.query)
}
inline ::DB::ProtoBsonObj* MongoFindReq::release_query() {
  
  ::DB::ProtoBsonObj* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoFindReq::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:DB.MongoFindReq.query)
  
  ::DB::ProtoBsonObj* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoFindReq::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::DB::ProtoBsonObj* MongoFindReq::mutable_query() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:DB.MongoFindReq.query)
  return _msg;
}
inline void MongoFindReq::set_allocated_query(::DB::ProtoBsonObj* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoFindReq.query)
}

// .DB.ProtoBsonObj fields = 4;
inline bool MongoFindReq::_internal_has_fields() const {
  return this != internal_default_instance() && _impl_.fields_ != nullptr;
}
inline bool MongoFindReq::has_fields() const {
  return _internal_has_fields();
}
inline void MongoFindReq::clear_fields() {
  if (GetArenaForAllocation() == nullptr && _impl_.fields_ != nullptr) {
    delete _impl_.fields_;
  }
  _impl_.fields_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoFindReq::_internal_fields() const {
  const ::DB::ProtoBsonObj* p = _impl_.fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoFindReq::fields() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.fields)
  return _internal_fields();
}
inline void MongoFindReq::unsafe_arena_set_allocated_fields(
    ::DB::ProtoBsonObj* fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_);
  }
  _impl_.fields_ = fields;
  if (fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoFindReq.fields)
}
inline ::DB::ProtoBsonObj* MongoFindReq::release_fields() {
  
  ::DB::ProtoBsonObj* temp = _impl_.fields_;
  _impl_.fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoFindReq::unsafe_arena_release_fields() {
  // @@protoc_insertion_point(field_release:DB.MongoFindReq.fields)
  
  ::DB::ProtoBsonObj* temp = _impl_.fields_;
  _impl_.fields_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoFindReq::_internal_mutable_fields() {
  
  if (_impl_.fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.fields_ = p;
  }
  return _impl_.fields_;
}
inline ::DB::ProtoBsonObj* MongoFindReq::mutable_fields() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_fields();
  // @@protoc_insertion_point(field_mutable:DB.MongoFindReq.fields)
  return _msg;
}
inline void MongoFindReq::set_allocated_fields(::DB::ProtoBsonObj* fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fields_;
  }
  if (fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fields);
    if (message_arena != submessage_arena) {
      fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fields_ = fields;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoFindReq.fields)
}

// int32 logic_batch_num = 5;
inline void MongoFindReq::clear_logic_batch_num() {
  _impl_.logic_batch_num_ = 0;
}
inline int32_t MongoFindReq::_internal_logic_batch_num() const {
  return _impl_.logic_batch_num_;
}
inline int32_t MongoFindReq::logic_batch_num() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.logic_batch_num)
  return _internal_logic_batch_num();
}
inline void MongoFindReq::_internal_set_logic_batch_num(int32_t value) {
  
  _impl_.logic_batch_num_ = value;
}
inline void MongoFindReq::set_logic_batch_num(int32_t value) {
  _internal_set_logic_batch_num(value);
  // @@protoc_insertion_point(field_set:DB.MongoFindReq.logic_batch_num)
}

// int32 skip = 6;
inline void MongoFindReq::clear_skip() {
  _impl_.skip_ = 0;
}
inline int32_t MongoFindReq::_internal_skip() const {
  return _impl_.skip_;
}
inline int32_t MongoFindReq::skip() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.skip)
  return _internal_skip();
}
inline void MongoFindReq::_internal_set_skip(int32_t value) {
  
  _impl_.skip_ = value;
}
inline void MongoFindReq::set_skip(int32_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:DB.MongoFindReq.skip)
}

// int32 limit = 7;
inline void MongoFindReq::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t MongoFindReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t MongoFindReq::limit() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.limit)
  return _internal_limit();
}
inline void MongoFindReq::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void MongoFindReq::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:DB.MongoFindReq.limit)
}

// int32 batch_size = 8;
inline void MongoFindReq::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t MongoFindReq::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t MongoFindReq::batch_size() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.batch_size)
  return _internal_batch_size();
}
inline void MongoFindReq::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void MongoFindReq::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:DB.MongoFindReq.batch_size)
}

// .DB.MongoUserData user_data = 9;
inline bool MongoFindReq::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoFindReq::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoFindReq::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoFindReq::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoFindReq::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindReq.user_data)
  return _internal_user_data();
}
inline void MongoFindReq::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoFindReq.user_data)
}
inline ::DB::MongoUserData* MongoFindReq::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoFindReq::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoFindReq.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoFindReq::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoFindReq::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoFindReq.user_data)
  return _msg;
}
inline void MongoFindReq::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoFindReq.user_data)
}

// -------------------------------------------------------------------

// MongoFindRes

// bool succeed = 1;
inline void MongoFindRes::clear_succeed() {
  _impl_.succeed_ = false;
}
inline bool MongoFindRes::_internal_succeed() const {
  return _impl_.succeed_;
}
inline bool MongoFindRes::succeed() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindRes.succeed)
  return _internal_succeed();
}
inline void MongoFindRes::_internal_set_succeed(bool value) {
  
  _impl_.succeed_ = value;
}
inline void MongoFindRes::set_succeed(bool value) {
  _internal_set_succeed(value);
  // @@protoc_insertion_point(field_set:DB.MongoFindRes.succeed)
}

// bool has_more = 2;
inline void MongoFindRes::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool MongoFindRes::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool MongoFindRes::has_more() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindRes.has_more)
  return _internal_has_more();
}
inline void MongoFindRes::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void MongoFindRes::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:DB.MongoFindRes.has_more)
}

// repeated .DB.ProtoBsonObj data_list = 3;
inline int MongoFindRes::_internal_data_list_size() const {
  return _impl_.data_list_.size();
}
inline int MongoFindRes::data_list_size() const {
  return _internal_data_list_size();
}
inline void MongoFindRes::clear_data_list() {
  _impl_.data_list_.Clear();
}
inline ::DB::ProtoBsonObj* MongoFindRes::mutable_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:DB.MongoFindRes.data_list)
  return _impl_.data_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >*
MongoFindRes::mutable_data_list() {
  // @@protoc_insertion_point(field_mutable_list:DB.MongoFindRes.data_list)
  return &_impl_.data_list_;
}
inline const ::DB::ProtoBsonObj& MongoFindRes::_internal_data_list(int index) const {
  return _impl_.data_list_.Get(index);
}
inline const ::DB::ProtoBsonObj& MongoFindRes::data_list(int index) const {
  // @@protoc_insertion_point(field_get:DB.MongoFindRes.data_list)
  return _internal_data_list(index);
}
inline ::DB::ProtoBsonObj* MongoFindRes::_internal_add_data_list() {
  return _impl_.data_list_.Add();
}
inline ::DB::ProtoBsonObj* MongoFindRes::add_data_list() {
  ::DB::ProtoBsonObj* _add = _internal_add_data_list();
  // @@protoc_insertion_point(field_add:DB.MongoFindRes.data_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >&
MongoFindRes::data_list() const {
  // @@protoc_insertion_point(field_list:DB.MongoFindRes.data_list)
  return _impl_.data_list_;
}

// .DB.MongoUserData user_data = 4;
inline bool MongoFindRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoFindRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoFindRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoFindRes::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoFindRes::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoFindRes.user_data)
  return _internal_user_data();
}
inline void MongoFindRes::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoFindRes.user_data)
}
inline ::DB::MongoUserData* MongoFindRes::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoFindRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoFindRes.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoFindRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoFindRes::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoFindRes.user_data)
  return _msg;
}
inline void MongoFindRes::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoFindRes.user_data)
}

// -------------------------------------------------------------------

// ProtoBsonBatchFindData

// string key = 1;
inline void ProtoBsonBatchFindData::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProtoBsonBatchFindData::key() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonBatchFindData.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonBatchFindData::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.ProtoBsonBatchFindData.key)
}
inline std::string* ProtoBsonBatchFindData::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:DB.ProtoBsonBatchFindData.key)
  return _s;
}
inline const std::string& ProtoBsonBatchFindData::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ProtoBsonBatchFindData::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonBatchFindData::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonBatchFindData::release_key() {
  // @@protoc_insertion_point(field_release:DB.ProtoBsonBatchFindData.key)
  return _impl_.key_.Release();
}
inline void ProtoBsonBatchFindData::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.ProtoBsonBatchFindData.key)
}

// int32 data_type = 2;
inline void ProtoBsonBatchFindData::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline int32_t ProtoBsonBatchFindData::_internal_data_type() const {
  return _impl_.data_type_;
}
inline int32_t ProtoBsonBatchFindData::data_type() const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonBatchFindData.data_type)
  return _internal_data_type();
}
inline void ProtoBsonBatchFindData::_internal_set_data_type(int32_t value) {
  
  _impl_.data_type_ = value;
}
inline void ProtoBsonBatchFindData::set_data_type(int32_t value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonBatchFindData.data_type)
}

// repeated int32 int32_var_list = 3;
inline int ProtoBsonBatchFindData::_internal_int32_var_list_size() const {
  return _impl_.int32_var_list_.size();
}
inline int ProtoBsonBatchFindData::int32_var_list_size() const {
  return _internal_int32_var_list_size();
}
inline void ProtoBsonBatchFindData::clear_int32_var_list() {
  _impl_.int32_var_list_.Clear();
}
inline int32_t ProtoBsonBatchFindData::_internal_int32_var_list(int index) const {
  return _impl_.int32_var_list_.Get(index);
}
inline int32_t ProtoBsonBatchFindData::int32_var_list(int index) const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonBatchFindData.int32_var_list)
  return _internal_int32_var_list(index);
}
inline void ProtoBsonBatchFindData::set_int32_var_list(int index, int32_t value) {
  _impl_.int32_var_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonBatchFindData.int32_var_list)
}
inline void ProtoBsonBatchFindData::_internal_add_int32_var_list(int32_t value) {
  _impl_.int32_var_list_.Add(value);
}
inline void ProtoBsonBatchFindData::add_int32_var_list(int32_t value) {
  _internal_add_int32_var_list(value);
  // @@protoc_insertion_point(field_add:DB.ProtoBsonBatchFindData.int32_var_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ProtoBsonBatchFindData::_internal_int32_var_list() const {
  return _impl_.int32_var_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ProtoBsonBatchFindData::int32_var_list() const {
  // @@protoc_insertion_point(field_list:DB.ProtoBsonBatchFindData.int32_var_list)
  return _internal_int32_var_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ProtoBsonBatchFindData::_internal_mutable_int32_var_list() {
  return &_impl_.int32_var_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ProtoBsonBatchFindData::mutable_int32_var_list() {
  // @@protoc_insertion_point(field_mutable_list:DB.ProtoBsonBatchFindData.int32_var_list)
  return _internal_mutable_int32_var_list();
}

// repeated int64 int64_var_list = 4;
inline int ProtoBsonBatchFindData::_internal_int64_var_list_size() const {
  return _impl_.int64_var_list_.size();
}
inline int ProtoBsonBatchFindData::int64_var_list_size() const {
  return _internal_int64_var_list_size();
}
inline void ProtoBsonBatchFindData::clear_int64_var_list() {
  _impl_.int64_var_list_.Clear();
}
inline int64_t ProtoBsonBatchFindData::_internal_int64_var_list(int index) const {
  return _impl_.int64_var_list_.Get(index);
}
inline int64_t ProtoBsonBatchFindData::int64_var_list(int index) const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonBatchFindData.int64_var_list)
  return _internal_int64_var_list(index);
}
inline void ProtoBsonBatchFindData::set_int64_var_list(int index, int64_t value) {
  _impl_.int64_var_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonBatchFindData.int64_var_list)
}
inline void ProtoBsonBatchFindData::_internal_add_int64_var_list(int64_t value) {
  _impl_.int64_var_list_.Add(value);
}
inline void ProtoBsonBatchFindData::add_int64_var_list(int64_t value) {
  _internal_add_int64_var_list(value);
  // @@protoc_insertion_point(field_add:DB.ProtoBsonBatchFindData.int64_var_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ProtoBsonBatchFindData::_internal_int64_var_list() const {
  return _impl_.int64_var_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ProtoBsonBatchFindData::int64_var_list() const {
  // @@protoc_insertion_point(field_list:DB.ProtoBsonBatchFindData.int64_var_list)
  return _internal_int64_var_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ProtoBsonBatchFindData::_internal_mutable_int64_var_list() {
  return &_impl_.int64_var_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ProtoBsonBatchFindData::mutable_int64_var_list() {
  // @@protoc_insertion_point(field_mutable_list:DB.ProtoBsonBatchFindData.int64_var_list)
  return _internal_mutable_int64_var_list();
}

// repeated string string_var_list = 5;
inline int ProtoBsonBatchFindData::_internal_string_var_list_size() const {
  return _impl_.string_var_list_.size();
}
inline int ProtoBsonBatchFindData::string_var_list_size() const {
  return _internal_string_var_list_size();
}
inline void ProtoBsonBatchFindData::clear_string_var_list() {
  _impl_.string_var_list_.Clear();
}
inline std::string* ProtoBsonBatchFindData::add_string_var_list() {
  std::string* _s = _internal_add_string_var_list();
  // @@protoc_insertion_point(field_add_mutable:DB.ProtoBsonBatchFindData.string_var_list)
  return _s;
}
inline const std::string& ProtoBsonBatchFindData::_internal_string_var_list(int index) const {
  return _impl_.string_var_list_.Get(index);
}
inline const std::string& ProtoBsonBatchFindData::string_var_list(int index) const {
  // @@protoc_insertion_point(field_get:DB.ProtoBsonBatchFindData.string_var_list)
  return _internal_string_var_list(index);
}
inline std::string* ProtoBsonBatchFindData::mutable_string_var_list(int index) {
  // @@protoc_insertion_point(field_mutable:DB.ProtoBsonBatchFindData.string_var_list)
  return _impl_.string_var_list_.Mutable(index);
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, const std::string& value) {
  _impl_.string_var_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:DB.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, std::string&& value) {
  _impl_.string_var_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:DB.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.string_var_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DB.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, const char* value, size_t size) {
  _impl_.string_var_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DB.ProtoBsonBatchFindData.string_var_list)
}
inline std::string* ProtoBsonBatchFindData::_internal_add_string_var_list() {
  return _impl_.string_var_list_.Add();
}
inline void ProtoBsonBatchFindData::add_string_var_list(const std::string& value) {
  _impl_.string_var_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DB.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::add_string_var_list(std::string&& value) {
  _impl_.string_var_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DB.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::add_string_var_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.string_var_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DB.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::add_string_var_list(const char* value, size_t size) {
  _impl_.string_var_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DB.ProtoBsonBatchFindData.string_var_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProtoBsonBatchFindData::string_var_list() const {
  // @@protoc_insertion_point(field_list:DB.ProtoBsonBatchFindData.string_var_list)
  return _impl_.string_var_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProtoBsonBatchFindData::mutable_string_var_list() {
  // @@protoc_insertion_point(field_mutable_list:DB.ProtoBsonBatchFindData.string_var_list)
  return &_impl_.string_var_list_;
}

// -------------------------------------------------------------------

// MongoBatchFindReq

// string db_name = 1;
inline void MongoBatchFindReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoBatchFindReq::db_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoBatchFindReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindReq.db_name)
}
inline std::string* MongoBatchFindReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindReq.db_name)
  return _s;
}
inline const std::string& MongoBatchFindReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoBatchFindReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::release_db_name() {
  // @@protoc_insertion_point(field_release:DB.MongoBatchFindReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoBatchFindReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoBatchFindReq.db_name)
}

// string col_name = 2;
inline void MongoBatchFindReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoBatchFindReq::col_name() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoBatchFindReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindReq.col_name)
}
inline std::string* MongoBatchFindReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindReq.col_name)
  return _s;
}
inline const std::string& MongoBatchFindReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoBatchFindReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::release_col_name() {
  // @@protoc_insertion_point(field_release:DB.MongoBatchFindReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoBatchFindReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DB.MongoBatchFindReq.col_name)
}

// .DB.ProtoBsonBatchFindData query = 3;
inline bool MongoBatchFindReq::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool MongoBatchFindReq::has_query() const {
  return _internal_has_query();
}
inline void MongoBatchFindReq::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::DB::ProtoBsonBatchFindData& MongoBatchFindReq::_internal_query() const {
  const ::DB::ProtoBsonBatchFindData* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonBatchFindData&>(
      ::DB::_ProtoBsonBatchFindData_default_instance_);
}
inline const ::DB::ProtoBsonBatchFindData& MongoBatchFindReq::query() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.query)
  return _internal_query();
}
inline void MongoBatchFindReq::unsafe_arena_set_allocated_query(
    ::DB::ProtoBsonBatchFindData* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoBatchFindReq.query)
}
inline ::DB::ProtoBsonBatchFindData* MongoBatchFindReq::release_query() {
  
  ::DB::ProtoBsonBatchFindData* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonBatchFindData* MongoBatchFindReq::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:DB.MongoBatchFindReq.query)
  
  ::DB::ProtoBsonBatchFindData* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonBatchFindData* MongoBatchFindReq::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonBatchFindData>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::DB::ProtoBsonBatchFindData* MongoBatchFindReq::mutable_query() {
  ::DB::ProtoBsonBatchFindData* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindReq.query)
  return _msg;
}
inline void MongoBatchFindReq::set_allocated_query(::DB::ProtoBsonBatchFindData* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoBatchFindReq.query)
}

// .DB.ProtoBsonObj fields = 4;
inline bool MongoBatchFindReq::_internal_has_fields() const {
  return this != internal_default_instance() && _impl_.fields_ != nullptr;
}
inline bool MongoBatchFindReq::has_fields() const {
  return _internal_has_fields();
}
inline void MongoBatchFindReq::clear_fields() {
  if (GetArenaForAllocation() == nullptr && _impl_.fields_ != nullptr) {
    delete _impl_.fields_;
  }
  _impl_.fields_ = nullptr;
}
inline const ::DB::ProtoBsonObj& MongoBatchFindReq::_internal_fields() const {
  const ::DB::ProtoBsonObj* p = _impl_.fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::ProtoBsonObj&>(
      ::DB::_ProtoBsonObj_default_instance_);
}
inline const ::DB::ProtoBsonObj& MongoBatchFindReq::fields() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.fields)
  return _internal_fields();
}
inline void MongoBatchFindReq::unsafe_arena_set_allocated_fields(
    ::DB::ProtoBsonObj* fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_);
  }
  _impl_.fields_ = fields;
  if (fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoBatchFindReq.fields)
}
inline ::DB::ProtoBsonObj* MongoBatchFindReq::release_fields() {
  
  ::DB::ProtoBsonObj* temp = _impl_.fields_;
  _impl_.fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::ProtoBsonObj* MongoBatchFindReq::unsafe_arena_release_fields() {
  // @@protoc_insertion_point(field_release:DB.MongoBatchFindReq.fields)
  
  ::DB::ProtoBsonObj* temp = _impl_.fields_;
  _impl_.fields_ = nullptr;
  return temp;
}
inline ::DB::ProtoBsonObj* MongoBatchFindReq::_internal_mutable_fields() {
  
  if (_impl_.fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.fields_ = p;
  }
  return _impl_.fields_;
}
inline ::DB::ProtoBsonObj* MongoBatchFindReq::mutable_fields() {
  ::DB::ProtoBsonObj* _msg = _internal_mutable_fields();
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindReq.fields)
  return _msg;
}
inline void MongoBatchFindReq::set_allocated_fields(::DB::ProtoBsonObj* fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fields_;
  }
  if (fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fields);
    if (message_arena != submessage_arena) {
      fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fields_ = fields;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoBatchFindReq.fields)
}

// int32 logic_batch_num = 5;
inline void MongoBatchFindReq::clear_logic_batch_num() {
  _impl_.logic_batch_num_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_logic_batch_num() const {
  return _impl_.logic_batch_num_;
}
inline int32_t MongoBatchFindReq::logic_batch_num() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.logic_batch_num)
  return _internal_logic_batch_num();
}
inline void MongoBatchFindReq::_internal_set_logic_batch_num(int32_t value) {
  
  _impl_.logic_batch_num_ = value;
}
inline void MongoBatchFindReq::set_logic_batch_num(int32_t value) {
  _internal_set_logic_batch_num(value);
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindReq.logic_batch_num)
}

// int32 skip = 6;
inline void MongoBatchFindReq::clear_skip() {
  _impl_.skip_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_skip() const {
  return _impl_.skip_;
}
inline int32_t MongoBatchFindReq::skip() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.skip)
  return _internal_skip();
}
inline void MongoBatchFindReq::_internal_set_skip(int32_t value) {
  
  _impl_.skip_ = value;
}
inline void MongoBatchFindReq::set_skip(int32_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindReq.skip)
}

// int32 limit = 7;
inline void MongoBatchFindReq::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t MongoBatchFindReq::limit() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.limit)
  return _internal_limit();
}
inline void MongoBatchFindReq::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void MongoBatchFindReq::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindReq.limit)
}

// int32 batch_size = 8;
inline void MongoBatchFindReq::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t MongoBatchFindReq::batch_size() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.batch_size)
  return _internal_batch_size();
}
inline void MongoBatchFindReq::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void MongoBatchFindReq::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindReq.batch_size)
}

// .DB.MongoUserData user_data = 9;
inline bool MongoBatchFindReq::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoBatchFindReq::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoBatchFindReq::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoBatchFindReq::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoBatchFindReq::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindReq.user_data)
  return _internal_user_data();
}
inline void MongoBatchFindReq::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoBatchFindReq.user_data)
}
inline ::DB::MongoUserData* MongoBatchFindReq::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoBatchFindReq::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoBatchFindReq.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoBatchFindReq::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoBatchFindReq::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindReq.user_data)
  return _msg;
}
inline void MongoBatchFindReq::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoBatchFindReq.user_data)
}

// -------------------------------------------------------------------

// MongoBatchFindRes

// bool succeed = 1;
inline void MongoBatchFindRes::clear_succeed() {
  _impl_.succeed_ = false;
}
inline bool MongoBatchFindRes::_internal_succeed() const {
  return _impl_.succeed_;
}
inline bool MongoBatchFindRes::succeed() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindRes.succeed)
  return _internal_succeed();
}
inline void MongoBatchFindRes::_internal_set_succeed(bool value) {
  
  _impl_.succeed_ = value;
}
inline void MongoBatchFindRes::set_succeed(bool value) {
  _internal_set_succeed(value);
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindRes.succeed)
}

// bool has_more = 2;
inline void MongoBatchFindRes::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool MongoBatchFindRes::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool MongoBatchFindRes::has_more() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindRes.has_more)
  return _internal_has_more();
}
inline void MongoBatchFindRes::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void MongoBatchFindRes::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:DB.MongoBatchFindRes.has_more)
}

// repeated .DB.ProtoBsonObj data_list = 3;
inline int MongoBatchFindRes::_internal_data_list_size() const {
  return _impl_.data_list_.size();
}
inline int MongoBatchFindRes::data_list_size() const {
  return _internal_data_list_size();
}
inline void MongoBatchFindRes::clear_data_list() {
  _impl_.data_list_.Clear();
}
inline ::DB::ProtoBsonObj* MongoBatchFindRes::mutable_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindRes.data_list)
  return _impl_.data_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >*
MongoBatchFindRes::mutable_data_list() {
  // @@protoc_insertion_point(field_mutable_list:DB.MongoBatchFindRes.data_list)
  return &_impl_.data_list_;
}
inline const ::DB::ProtoBsonObj& MongoBatchFindRes::_internal_data_list(int index) const {
  return _impl_.data_list_.Get(index);
}
inline const ::DB::ProtoBsonObj& MongoBatchFindRes::data_list(int index) const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindRes.data_list)
  return _internal_data_list(index);
}
inline ::DB::ProtoBsonObj* MongoBatchFindRes::_internal_add_data_list() {
  return _impl_.data_list_.Add();
}
inline ::DB::ProtoBsonObj* MongoBatchFindRes::add_data_list() {
  ::DB::ProtoBsonObj* _add = _internal_add_data_list();
  // @@protoc_insertion_point(field_add:DB.MongoBatchFindRes.data_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::DB::ProtoBsonObj >&
MongoBatchFindRes::data_list() const {
  // @@protoc_insertion_point(field_list:DB.MongoBatchFindRes.data_list)
  return _impl_.data_list_;
}

// .DB.MongoUserData user_data = 4;
inline bool MongoBatchFindRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoBatchFindRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoBatchFindRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::DB::MongoUserData& MongoBatchFindRes::_internal_user_data() const {
  const ::DB::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUserData&>(
      ::DB::_MongoUserData_default_instance_);
}
inline const ::DB::MongoUserData& MongoBatchFindRes::user_data() const {
  // @@protoc_insertion_point(field_get:DB.MongoBatchFindRes.user_data)
  return _internal_user_data();
}
inline void MongoBatchFindRes::unsafe_arena_set_allocated_user_data(
    ::DB::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoBatchFindRes.user_data)
}
inline ::DB::MongoUserData* MongoBatchFindRes::release_user_data() {
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUserData* MongoBatchFindRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:DB.MongoBatchFindRes.user_data)
  
  ::DB::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::DB::MongoUserData* MongoBatchFindRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::DB::MongoUserData* MongoBatchFindRes::mutable_user_data() {
  ::DB::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:DB.MongoBatchFindRes.user_data)
  return _msg;
}
inline void MongoBatchFindRes::set_allocated_user_data(::DB::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoBatchFindRes.user_data)
}

// -------------------------------------------------------------------

// MongoDBMsg

// int32 cmd_type = 1;
inline void MongoDBMsg::clear_cmd_type() {
  _impl_.cmd_type_ = 0;
}
inline int32_t MongoDBMsg::_internal_cmd_type() const {
  return _impl_.cmd_type_;
}
inline int32_t MongoDBMsg::cmd_type() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.cmd_type)
  return _internal_cmd_type();
}
inline void MongoDBMsg::_internal_set_cmd_type(int32_t value) {
  
  _impl_.cmd_type_ = value;
}
inline void MongoDBMsg::set_cmd_type(int32_t value) {
  _internal_set_cmd_type(value);
  // @@protoc_insertion_point(field_set:DB.MongoDBMsg.cmd_type)
}

// .DB.MongoInsertReq insert_req = 2;
inline bool MongoDBMsg::_internal_has_insert_req() const {
  return this != internal_default_instance() && _impl_.insert_req_ != nullptr;
}
inline bool MongoDBMsg::has_insert_req() const {
  return _internal_has_insert_req();
}
inline void MongoDBMsg::clear_insert_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.insert_req_ != nullptr) {
    delete _impl_.insert_req_;
  }
  _impl_.insert_req_ = nullptr;
}
inline const ::DB::MongoInsertReq& MongoDBMsg::_internal_insert_req() const {
  const ::DB::MongoInsertReq* p = _impl_.insert_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoInsertReq&>(
      ::DB::_MongoInsertReq_default_instance_);
}
inline const ::DB::MongoInsertReq& MongoDBMsg::insert_req() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.insert_req)
  return _internal_insert_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_insert_req(
    ::DB::MongoInsertReq* insert_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.insert_req_);
  }
  _impl_.insert_req_ = insert_req;
  if (insert_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.insert_req)
}
inline ::DB::MongoInsertReq* MongoDBMsg::release_insert_req() {
  
  ::DB::MongoInsertReq* temp = _impl_.insert_req_;
  _impl_.insert_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoInsertReq* MongoDBMsg::unsafe_arena_release_insert_req() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.insert_req)
  
  ::DB::MongoInsertReq* temp = _impl_.insert_req_;
  _impl_.insert_req_ = nullptr;
  return temp;
}
inline ::DB::MongoInsertReq* MongoDBMsg::_internal_mutable_insert_req() {
  
  if (_impl_.insert_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoInsertReq>(GetArenaForAllocation());
    _impl_.insert_req_ = p;
  }
  return _impl_.insert_req_;
}
inline ::DB::MongoInsertReq* MongoDBMsg::mutable_insert_req() {
  ::DB::MongoInsertReq* _msg = _internal_mutable_insert_req();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.insert_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_insert_req(::DB::MongoInsertReq* insert_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.insert_req_;
  }
  if (insert_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(insert_req);
    if (message_arena != submessage_arena) {
      insert_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.insert_req_ = insert_req;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.insert_req)
}

// .DB.MongoInsertRes insert_res = 3;
inline bool MongoDBMsg::_internal_has_insert_res() const {
  return this != internal_default_instance() && _impl_.insert_res_ != nullptr;
}
inline bool MongoDBMsg::has_insert_res() const {
  return _internal_has_insert_res();
}
inline void MongoDBMsg::clear_insert_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.insert_res_ != nullptr) {
    delete _impl_.insert_res_;
  }
  _impl_.insert_res_ = nullptr;
}
inline const ::DB::MongoInsertRes& MongoDBMsg::_internal_insert_res() const {
  const ::DB::MongoInsertRes* p = _impl_.insert_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoInsertRes&>(
      ::DB::_MongoInsertRes_default_instance_);
}
inline const ::DB::MongoInsertRes& MongoDBMsg::insert_res() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.insert_res)
  return _internal_insert_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_insert_res(
    ::DB::MongoInsertRes* insert_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.insert_res_);
  }
  _impl_.insert_res_ = insert_res;
  if (insert_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.insert_res)
}
inline ::DB::MongoInsertRes* MongoDBMsg::release_insert_res() {
  
  ::DB::MongoInsertRes* temp = _impl_.insert_res_;
  _impl_.insert_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoInsertRes* MongoDBMsg::unsafe_arena_release_insert_res() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.insert_res)
  
  ::DB::MongoInsertRes* temp = _impl_.insert_res_;
  _impl_.insert_res_ = nullptr;
  return temp;
}
inline ::DB::MongoInsertRes* MongoDBMsg::_internal_mutable_insert_res() {
  
  if (_impl_.insert_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoInsertRes>(GetArenaForAllocation());
    _impl_.insert_res_ = p;
  }
  return _impl_.insert_res_;
}
inline ::DB::MongoInsertRes* MongoDBMsg::mutable_insert_res() {
  ::DB::MongoInsertRes* _msg = _internal_mutable_insert_res();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.insert_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_insert_res(::DB::MongoInsertRes* insert_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.insert_res_;
  }
  if (insert_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(insert_res);
    if (message_arena != submessage_arena) {
      insert_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.insert_res_ = insert_res;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.insert_res)
}

// .DB.MongoRemoveReq remove_req = 4;
inline bool MongoDBMsg::_internal_has_remove_req() const {
  return this != internal_default_instance() && _impl_.remove_req_ != nullptr;
}
inline bool MongoDBMsg::has_remove_req() const {
  return _internal_has_remove_req();
}
inline void MongoDBMsg::clear_remove_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.remove_req_ != nullptr) {
    delete _impl_.remove_req_;
  }
  _impl_.remove_req_ = nullptr;
}
inline const ::DB::MongoRemoveReq& MongoDBMsg::_internal_remove_req() const {
  const ::DB::MongoRemoveReq* p = _impl_.remove_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoRemoveReq&>(
      ::DB::_MongoRemoveReq_default_instance_);
}
inline const ::DB::MongoRemoveReq& MongoDBMsg::remove_req() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.remove_req)
  return _internal_remove_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_remove_req(
    ::DB::MongoRemoveReq* remove_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remove_req_);
  }
  _impl_.remove_req_ = remove_req;
  if (remove_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.remove_req)
}
inline ::DB::MongoRemoveReq* MongoDBMsg::release_remove_req() {
  
  ::DB::MongoRemoveReq* temp = _impl_.remove_req_;
  _impl_.remove_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoRemoveReq* MongoDBMsg::unsafe_arena_release_remove_req() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.remove_req)
  
  ::DB::MongoRemoveReq* temp = _impl_.remove_req_;
  _impl_.remove_req_ = nullptr;
  return temp;
}
inline ::DB::MongoRemoveReq* MongoDBMsg::_internal_mutable_remove_req() {
  
  if (_impl_.remove_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoRemoveReq>(GetArenaForAllocation());
    _impl_.remove_req_ = p;
  }
  return _impl_.remove_req_;
}
inline ::DB::MongoRemoveReq* MongoDBMsg::mutable_remove_req() {
  ::DB::MongoRemoveReq* _msg = _internal_mutable_remove_req();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.remove_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_remove_req(::DB::MongoRemoveReq* remove_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remove_req_;
  }
  if (remove_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remove_req);
    if (message_arena != submessage_arena) {
      remove_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remove_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remove_req_ = remove_req;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.remove_req)
}

// .DB.MongoRemoveRes remove_res = 5;
inline bool MongoDBMsg::_internal_has_remove_res() const {
  return this != internal_default_instance() && _impl_.remove_res_ != nullptr;
}
inline bool MongoDBMsg::has_remove_res() const {
  return _internal_has_remove_res();
}
inline void MongoDBMsg::clear_remove_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.remove_res_ != nullptr) {
    delete _impl_.remove_res_;
  }
  _impl_.remove_res_ = nullptr;
}
inline const ::DB::MongoRemoveRes& MongoDBMsg::_internal_remove_res() const {
  const ::DB::MongoRemoveRes* p = _impl_.remove_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoRemoveRes&>(
      ::DB::_MongoRemoveRes_default_instance_);
}
inline const ::DB::MongoRemoveRes& MongoDBMsg::remove_res() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.remove_res)
  return _internal_remove_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_remove_res(
    ::DB::MongoRemoveRes* remove_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remove_res_);
  }
  _impl_.remove_res_ = remove_res;
  if (remove_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.remove_res)
}
inline ::DB::MongoRemoveRes* MongoDBMsg::release_remove_res() {
  
  ::DB::MongoRemoveRes* temp = _impl_.remove_res_;
  _impl_.remove_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoRemoveRes* MongoDBMsg::unsafe_arena_release_remove_res() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.remove_res)
  
  ::DB::MongoRemoveRes* temp = _impl_.remove_res_;
  _impl_.remove_res_ = nullptr;
  return temp;
}
inline ::DB::MongoRemoveRes* MongoDBMsg::_internal_mutable_remove_res() {
  
  if (_impl_.remove_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoRemoveRes>(GetArenaForAllocation());
    _impl_.remove_res_ = p;
  }
  return _impl_.remove_res_;
}
inline ::DB::MongoRemoveRes* MongoDBMsg::mutable_remove_res() {
  ::DB::MongoRemoveRes* _msg = _internal_mutable_remove_res();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.remove_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_remove_res(::DB::MongoRemoveRes* remove_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remove_res_;
  }
  if (remove_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remove_res);
    if (message_arena != submessage_arena) {
      remove_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remove_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remove_res_ = remove_res;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.remove_res)
}

// .DB.MongoSaveReq save_req = 6;
inline bool MongoDBMsg::_internal_has_save_req() const {
  return this != internal_default_instance() && _impl_.save_req_ != nullptr;
}
inline bool MongoDBMsg::has_save_req() const {
  return _internal_has_save_req();
}
inline void MongoDBMsg::clear_save_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.save_req_ != nullptr) {
    delete _impl_.save_req_;
  }
  _impl_.save_req_ = nullptr;
}
inline const ::DB::MongoSaveReq& MongoDBMsg::_internal_save_req() const {
  const ::DB::MongoSaveReq* p = _impl_.save_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoSaveReq&>(
      ::DB::_MongoSaveReq_default_instance_);
}
inline const ::DB::MongoSaveReq& MongoDBMsg::save_req() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.save_req)
  return _internal_save_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_save_req(
    ::DB::MongoSaveReq* save_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_req_);
  }
  _impl_.save_req_ = save_req;
  if (save_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.save_req)
}
inline ::DB::MongoSaveReq* MongoDBMsg::release_save_req() {
  
  ::DB::MongoSaveReq* temp = _impl_.save_req_;
  _impl_.save_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoSaveReq* MongoDBMsg::unsafe_arena_release_save_req() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.save_req)
  
  ::DB::MongoSaveReq* temp = _impl_.save_req_;
  _impl_.save_req_ = nullptr;
  return temp;
}
inline ::DB::MongoSaveReq* MongoDBMsg::_internal_mutable_save_req() {
  
  if (_impl_.save_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoSaveReq>(GetArenaForAllocation());
    _impl_.save_req_ = p;
  }
  return _impl_.save_req_;
}
inline ::DB::MongoSaveReq* MongoDBMsg::mutable_save_req() {
  ::DB::MongoSaveReq* _msg = _internal_mutable_save_req();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.save_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_save_req(::DB::MongoSaveReq* save_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_req_;
  }
  if (save_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_req);
    if (message_arena != submessage_arena) {
      save_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.save_req_ = save_req;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.save_req)
}

// .DB.MongoSaveRes save_res = 7;
inline bool MongoDBMsg::_internal_has_save_res() const {
  return this != internal_default_instance() && _impl_.save_res_ != nullptr;
}
inline bool MongoDBMsg::has_save_res() const {
  return _internal_has_save_res();
}
inline void MongoDBMsg::clear_save_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.save_res_ != nullptr) {
    delete _impl_.save_res_;
  }
  _impl_.save_res_ = nullptr;
}
inline const ::DB::MongoSaveRes& MongoDBMsg::_internal_save_res() const {
  const ::DB::MongoSaveRes* p = _impl_.save_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoSaveRes&>(
      ::DB::_MongoSaveRes_default_instance_);
}
inline const ::DB::MongoSaveRes& MongoDBMsg::save_res() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.save_res)
  return _internal_save_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_save_res(
    ::DB::MongoSaveRes* save_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_res_);
  }
  _impl_.save_res_ = save_res;
  if (save_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.save_res)
}
inline ::DB::MongoSaveRes* MongoDBMsg::release_save_res() {
  
  ::DB::MongoSaveRes* temp = _impl_.save_res_;
  _impl_.save_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoSaveRes* MongoDBMsg::unsafe_arena_release_save_res() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.save_res)
  
  ::DB::MongoSaveRes* temp = _impl_.save_res_;
  _impl_.save_res_ = nullptr;
  return temp;
}
inline ::DB::MongoSaveRes* MongoDBMsg::_internal_mutable_save_res() {
  
  if (_impl_.save_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoSaveRes>(GetArenaForAllocation());
    _impl_.save_res_ = p;
  }
  return _impl_.save_res_;
}
inline ::DB::MongoSaveRes* MongoDBMsg::mutable_save_res() {
  ::DB::MongoSaveRes* _msg = _internal_mutable_save_res();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.save_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_save_res(::DB::MongoSaveRes* save_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_res_;
  }
  if (save_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_res);
    if (message_arena != submessage_arena) {
      save_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.save_res_ = save_res;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.save_res)
}

// .DB.MongoUpdateReq update_req = 8;
inline bool MongoDBMsg::_internal_has_update_req() const {
  return this != internal_default_instance() && _impl_.update_req_ != nullptr;
}
inline bool MongoDBMsg::has_update_req() const {
  return _internal_has_update_req();
}
inline void MongoDBMsg::clear_update_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_req_ != nullptr) {
    delete _impl_.update_req_;
  }
  _impl_.update_req_ = nullptr;
}
inline const ::DB::MongoUpdateReq& MongoDBMsg::_internal_update_req() const {
  const ::DB::MongoUpdateReq* p = _impl_.update_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUpdateReq&>(
      ::DB::_MongoUpdateReq_default_instance_);
}
inline const ::DB::MongoUpdateReq& MongoDBMsg::update_req() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.update_req)
  return _internal_update_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_update_req(
    ::DB::MongoUpdateReq* update_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_req_);
  }
  _impl_.update_req_ = update_req;
  if (update_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.update_req)
}
inline ::DB::MongoUpdateReq* MongoDBMsg::release_update_req() {
  
  ::DB::MongoUpdateReq* temp = _impl_.update_req_;
  _impl_.update_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUpdateReq* MongoDBMsg::unsafe_arena_release_update_req() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.update_req)
  
  ::DB::MongoUpdateReq* temp = _impl_.update_req_;
  _impl_.update_req_ = nullptr;
  return temp;
}
inline ::DB::MongoUpdateReq* MongoDBMsg::_internal_mutable_update_req() {
  
  if (_impl_.update_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUpdateReq>(GetArenaForAllocation());
    _impl_.update_req_ = p;
  }
  return _impl_.update_req_;
}
inline ::DB::MongoUpdateReq* MongoDBMsg::mutable_update_req() {
  ::DB::MongoUpdateReq* _msg = _internal_mutable_update_req();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.update_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_update_req(::DB::MongoUpdateReq* update_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.update_req_;
  }
  if (update_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_req);
    if (message_arena != submessage_arena) {
      update_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_req_ = update_req;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.update_req)
}

// .DB.MongoUpdateRes update_res = 9;
inline bool MongoDBMsg::_internal_has_update_res() const {
  return this != internal_default_instance() && _impl_.update_res_ != nullptr;
}
inline bool MongoDBMsg::has_update_res() const {
  return _internal_has_update_res();
}
inline void MongoDBMsg::clear_update_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.update_res_ != nullptr) {
    delete _impl_.update_res_;
  }
  _impl_.update_res_ = nullptr;
}
inline const ::DB::MongoUpdateRes& MongoDBMsg::_internal_update_res() const {
  const ::DB::MongoUpdateRes* p = _impl_.update_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoUpdateRes&>(
      ::DB::_MongoUpdateRes_default_instance_);
}
inline const ::DB::MongoUpdateRes& MongoDBMsg::update_res() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.update_res)
  return _internal_update_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_update_res(
    ::DB::MongoUpdateRes* update_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_res_);
  }
  _impl_.update_res_ = update_res;
  if (update_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.update_res)
}
inline ::DB::MongoUpdateRes* MongoDBMsg::release_update_res() {
  
  ::DB::MongoUpdateRes* temp = _impl_.update_res_;
  _impl_.update_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoUpdateRes* MongoDBMsg::unsafe_arena_release_update_res() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.update_res)
  
  ::DB::MongoUpdateRes* temp = _impl_.update_res_;
  _impl_.update_res_ = nullptr;
  return temp;
}
inline ::DB::MongoUpdateRes* MongoDBMsg::_internal_mutable_update_res() {
  
  if (_impl_.update_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoUpdateRes>(GetArenaForAllocation());
    _impl_.update_res_ = p;
  }
  return _impl_.update_res_;
}
inline ::DB::MongoUpdateRes* MongoDBMsg::mutable_update_res() {
  ::DB::MongoUpdateRes* _msg = _internal_mutable_update_res();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.update_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_update_res(::DB::MongoUpdateRes* update_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.update_res_;
  }
  if (update_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_res);
    if (message_arena != submessage_arena) {
      update_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, update_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.update_res_ = update_res;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.update_res)
}

// .DB.MongoFindReq find_req = 10;
inline bool MongoDBMsg::_internal_has_find_req() const {
  return this != internal_default_instance() && _impl_.find_req_ != nullptr;
}
inline bool MongoDBMsg::has_find_req() const {
  return _internal_has_find_req();
}
inline void MongoDBMsg::clear_find_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.find_req_ != nullptr) {
    delete _impl_.find_req_;
  }
  _impl_.find_req_ = nullptr;
}
inline const ::DB::MongoFindReq& MongoDBMsg::_internal_find_req() const {
  const ::DB::MongoFindReq* p = _impl_.find_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoFindReq&>(
      ::DB::_MongoFindReq_default_instance_);
}
inline const ::DB::MongoFindReq& MongoDBMsg::find_req() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.find_req)
  return _internal_find_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_find_req(
    ::DB::MongoFindReq* find_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.find_req_);
  }
  _impl_.find_req_ = find_req;
  if (find_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.find_req)
}
inline ::DB::MongoFindReq* MongoDBMsg::release_find_req() {
  
  ::DB::MongoFindReq* temp = _impl_.find_req_;
  _impl_.find_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoFindReq* MongoDBMsg::unsafe_arena_release_find_req() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.find_req)
  
  ::DB::MongoFindReq* temp = _impl_.find_req_;
  _impl_.find_req_ = nullptr;
  return temp;
}
inline ::DB::MongoFindReq* MongoDBMsg::_internal_mutable_find_req() {
  
  if (_impl_.find_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoFindReq>(GetArenaForAllocation());
    _impl_.find_req_ = p;
  }
  return _impl_.find_req_;
}
inline ::DB::MongoFindReq* MongoDBMsg::mutable_find_req() {
  ::DB::MongoFindReq* _msg = _internal_mutable_find_req();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.find_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_find_req(::DB::MongoFindReq* find_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.find_req_;
  }
  if (find_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(find_req);
    if (message_arena != submessage_arena) {
      find_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, find_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.find_req_ = find_req;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.find_req)
}

// .DB.MongoFindRes find_res = 11;
inline bool MongoDBMsg::_internal_has_find_res() const {
  return this != internal_default_instance() && _impl_.find_res_ != nullptr;
}
inline bool MongoDBMsg::has_find_res() const {
  return _internal_has_find_res();
}
inline void MongoDBMsg::clear_find_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.find_res_ != nullptr) {
    delete _impl_.find_res_;
  }
  _impl_.find_res_ = nullptr;
}
inline const ::DB::MongoFindRes& MongoDBMsg::_internal_find_res() const {
  const ::DB::MongoFindRes* p = _impl_.find_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoFindRes&>(
      ::DB::_MongoFindRes_default_instance_);
}
inline const ::DB::MongoFindRes& MongoDBMsg::find_res() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.find_res)
  return _internal_find_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_find_res(
    ::DB::MongoFindRes* find_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.find_res_);
  }
  _impl_.find_res_ = find_res;
  if (find_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.find_res)
}
inline ::DB::MongoFindRes* MongoDBMsg::release_find_res() {
  
  ::DB::MongoFindRes* temp = _impl_.find_res_;
  _impl_.find_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoFindRes* MongoDBMsg::unsafe_arena_release_find_res() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.find_res)
  
  ::DB::MongoFindRes* temp = _impl_.find_res_;
  _impl_.find_res_ = nullptr;
  return temp;
}
inline ::DB::MongoFindRes* MongoDBMsg::_internal_mutable_find_res() {
  
  if (_impl_.find_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoFindRes>(GetArenaForAllocation());
    _impl_.find_res_ = p;
  }
  return _impl_.find_res_;
}
inline ::DB::MongoFindRes* MongoDBMsg::mutable_find_res() {
  ::DB::MongoFindRes* _msg = _internal_mutable_find_res();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.find_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_find_res(::DB::MongoFindRes* find_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.find_res_;
  }
  if (find_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(find_res);
    if (message_arena != submessage_arena) {
      find_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, find_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.find_res_ = find_res;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.find_res)
}

// .DB.MongoBatchFindReq batch_find_req = 12;
inline bool MongoDBMsg::_internal_has_batch_find_req() const {
  return this != internal_default_instance() && _impl_.batch_find_req_ != nullptr;
}
inline bool MongoDBMsg::has_batch_find_req() const {
  return _internal_has_batch_find_req();
}
inline void MongoDBMsg::clear_batch_find_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.batch_find_req_ != nullptr) {
    delete _impl_.batch_find_req_;
  }
  _impl_.batch_find_req_ = nullptr;
}
inline const ::DB::MongoBatchFindReq& MongoDBMsg::_internal_batch_find_req() const {
  const ::DB::MongoBatchFindReq* p = _impl_.batch_find_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoBatchFindReq&>(
      ::DB::_MongoBatchFindReq_default_instance_);
}
inline const ::DB::MongoBatchFindReq& MongoDBMsg::batch_find_req() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.batch_find_req)
  return _internal_batch_find_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_batch_find_req(
    ::DB::MongoBatchFindReq* batch_find_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_find_req_);
  }
  _impl_.batch_find_req_ = batch_find_req;
  if (batch_find_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.batch_find_req)
}
inline ::DB::MongoBatchFindReq* MongoDBMsg::release_batch_find_req() {
  
  ::DB::MongoBatchFindReq* temp = _impl_.batch_find_req_;
  _impl_.batch_find_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoBatchFindReq* MongoDBMsg::unsafe_arena_release_batch_find_req() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.batch_find_req)
  
  ::DB::MongoBatchFindReq* temp = _impl_.batch_find_req_;
  _impl_.batch_find_req_ = nullptr;
  return temp;
}
inline ::DB::MongoBatchFindReq* MongoDBMsg::_internal_mutable_batch_find_req() {
  
  if (_impl_.batch_find_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoBatchFindReq>(GetArenaForAllocation());
    _impl_.batch_find_req_ = p;
  }
  return _impl_.batch_find_req_;
}
inline ::DB::MongoBatchFindReq* MongoDBMsg::mutable_batch_find_req() {
  ::DB::MongoBatchFindReq* _msg = _internal_mutable_batch_find_req();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.batch_find_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_batch_find_req(::DB::MongoBatchFindReq* batch_find_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.batch_find_req_;
  }
  if (batch_find_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(batch_find_req);
    if (message_arena != submessage_arena) {
      batch_find_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_find_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_find_req_ = batch_find_req;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.batch_find_req)
}

// .DB.MongoBatchFindRes batch_find_res = 13;
inline bool MongoDBMsg::_internal_has_batch_find_res() const {
  return this != internal_default_instance() && _impl_.batch_find_res_ != nullptr;
}
inline bool MongoDBMsg::has_batch_find_res() const {
  return _internal_has_batch_find_res();
}
inline void MongoDBMsg::clear_batch_find_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.batch_find_res_ != nullptr) {
    delete _impl_.batch_find_res_;
  }
  _impl_.batch_find_res_ = nullptr;
}
inline const ::DB::MongoBatchFindRes& MongoDBMsg::_internal_batch_find_res() const {
  const ::DB::MongoBatchFindRes* p = _impl_.batch_find_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::DB::MongoBatchFindRes&>(
      ::DB::_MongoBatchFindRes_default_instance_);
}
inline const ::DB::MongoBatchFindRes& MongoDBMsg::batch_find_res() const {
  // @@protoc_insertion_point(field_get:DB.MongoDBMsg.batch_find_res)
  return _internal_batch_find_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_batch_find_res(
    ::DB::MongoBatchFindRes* batch_find_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_find_res_);
  }
  _impl_.batch_find_res_ = batch_find_res;
  if (batch_find_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DB.MongoDBMsg.batch_find_res)
}
inline ::DB::MongoBatchFindRes* MongoDBMsg::release_batch_find_res() {
  
  ::DB::MongoBatchFindRes* temp = _impl_.batch_find_res_;
  _impl_.batch_find_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::DB::MongoBatchFindRes* MongoDBMsg::unsafe_arena_release_batch_find_res() {
  // @@protoc_insertion_point(field_release:DB.MongoDBMsg.batch_find_res)
  
  ::DB::MongoBatchFindRes* temp = _impl_.batch_find_res_;
  _impl_.batch_find_res_ = nullptr;
  return temp;
}
inline ::DB::MongoBatchFindRes* MongoDBMsg::_internal_mutable_batch_find_res() {
  
  if (_impl_.batch_find_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::DB::MongoBatchFindRes>(GetArenaForAllocation());
    _impl_.batch_find_res_ = p;
  }
  return _impl_.batch_find_res_;
}
inline ::DB::MongoBatchFindRes* MongoDBMsg::mutable_batch_find_res() {
  ::DB::MongoBatchFindRes* _msg = _internal_mutable_batch_find_res();
  // @@protoc_insertion_point(field_mutable:DB.MongoDBMsg.batch_find_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_batch_find_res(::DB::MongoBatchFindRes* batch_find_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.batch_find_res_;
  }
  if (batch_find_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(batch_find_res);
    if (message_arena != submessage_arena) {
      batch_find_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_find_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_find_res_ = batch_find_res;
  // @@protoc_insertion_point(field_set_allocated:DB.MongoDBMsg.batch_find_res)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace DB

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::DB::MongoMsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DB::MongoMsgType>() {
  return ::DB::MongoMsgType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_5fmongo_5fproxy_2eproto
