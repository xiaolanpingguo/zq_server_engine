// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db_mongo_proxy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_5fmongo_5fproxy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_5fmongo_5fproxy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_5fmongo_5fproxy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_5fmongo_5fproxy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_5fmongo_5fproxy_2eproto;
namespace S2S {
class MongoBatchFindReq;
struct MongoBatchFindReqDefaultTypeInternal;
extern MongoBatchFindReqDefaultTypeInternal _MongoBatchFindReq_default_instance_;
class MongoBatchFindRes;
struct MongoBatchFindResDefaultTypeInternal;
extern MongoBatchFindResDefaultTypeInternal _MongoBatchFindRes_default_instance_;
class MongoDBMsg;
struct MongoDBMsgDefaultTypeInternal;
extern MongoDBMsgDefaultTypeInternal _MongoDBMsg_default_instance_;
class MongoFindReq;
struct MongoFindReqDefaultTypeInternal;
extern MongoFindReqDefaultTypeInternal _MongoFindReq_default_instance_;
class MongoFindRes;
struct MongoFindResDefaultTypeInternal;
extern MongoFindResDefaultTypeInternal _MongoFindRes_default_instance_;
class MongoInsertReq;
struct MongoInsertReqDefaultTypeInternal;
extern MongoInsertReqDefaultTypeInternal _MongoInsertReq_default_instance_;
class MongoInsertRes;
struct MongoInsertResDefaultTypeInternal;
extern MongoInsertResDefaultTypeInternal _MongoInsertRes_default_instance_;
class MongoRemoveReq;
struct MongoRemoveReqDefaultTypeInternal;
extern MongoRemoveReqDefaultTypeInternal _MongoRemoveReq_default_instance_;
class MongoRemoveRes;
struct MongoRemoveResDefaultTypeInternal;
extern MongoRemoveResDefaultTypeInternal _MongoRemoveRes_default_instance_;
class MongoSaveReq;
struct MongoSaveReqDefaultTypeInternal;
extern MongoSaveReqDefaultTypeInternal _MongoSaveReq_default_instance_;
class MongoSaveRes;
struct MongoSaveResDefaultTypeInternal;
extern MongoSaveResDefaultTypeInternal _MongoSaveRes_default_instance_;
class MongoUserData;
struct MongoUserDataDefaultTypeInternal;
extern MongoUserDataDefaultTypeInternal _MongoUserData_default_instance_;
class ProtoBsonBatchFindData;
struct ProtoBsonBatchFindDataDefaultTypeInternal;
extern ProtoBsonBatchFindDataDefaultTypeInternal _ProtoBsonBatchFindData_default_instance_;
class ProtoBsonData;
struct ProtoBsonDataDefaultTypeInternal;
extern ProtoBsonDataDefaultTypeInternal _ProtoBsonData_default_instance_;
class ProtoBsonObj;
struct ProtoBsonObjDefaultTypeInternal;
extern ProtoBsonObjDefaultTypeInternal _ProtoBsonObj_default_instance_;
}  // namespace S2S
PROTOBUF_NAMESPACE_OPEN
template<> ::S2S::MongoBatchFindReq* Arena::CreateMaybeMessage<::S2S::MongoBatchFindReq>(Arena*);
template<> ::S2S::MongoBatchFindRes* Arena::CreateMaybeMessage<::S2S::MongoBatchFindRes>(Arena*);
template<> ::S2S::MongoDBMsg* Arena::CreateMaybeMessage<::S2S::MongoDBMsg>(Arena*);
template<> ::S2S::MongoFindReq* Arena::CreateMaybeMessage<::S2S::MongoFindReq>(Arena*);
template<> ::S2S::MongoFindRes* Arena::CreateMaybeMessage<::S2S::MongoFindRes>(Arena*);
template<> ::S2S::MongoInsertReq* Arena::CreateMaybeMessage<::S2S::MongoInsertReq>(Arena*);
template<> ::S2S::MongoInsertRes* Arena::CreateMaybeMessage<::S2S::MongoInsertRes>(Arena*);
template<> ::S2S::MongoRemoveReq* Arena::CreateMaybeMessage<::S2S::MongoRemoveReq>(Arena*);
template<> ::S2S::MongoRemoveRes* Arena::CreateMaybeMessage<::S2S::MongoRemoveRes>(Arena*);
template<> ::S2S::MongoSaveReq* Arena::CreateMaybeMessage<::S2S::MongoSaveReq>(Arena*);
template<> ::S2S::MongoSaveRes* Arena::CreateMaybeMessage<::S2S::MongoSaveRes>(Arena*);
template<> ::S2S::MongoUserData* Arena::CreateMaybeMessage<::S2S::MongoUserData>(Arena*);
template<> ::S2S::ProtoBsonBatchFindData* Arena::CreateMaybeMessage<::S2S::ProtoBsonBatchFindData>(Arena*);
template<> ::S2S::ProtoBsonData* Arena::CreateMaybeMessage<::S2S::ProtoBsonData>(Arena*);
template<> ::S2S::ProtoBsonObj* Arena::CreateMaybeMessage<::S2S::ProtoBsonObj>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace S2S {

// ===================================================================

class ProtoBsonData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.ProtoBsonData) */ {
 public:
  inline ProtoBsonData() : ProtoBsonData(nullptr) {}
  ~ProtoBsonData() override;
  explicit PROTOBUF_CONSTEXPR ProtoBsonData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoBsonData(const ProtoBsonData& from);
  ProtoBsonData(ProtoBsonData&& from) noexcept
    : ProtoBsonData() {
    *this = ::std::move(from);
  }

  inline ProtoBsonData& operator=(const ProtoBsonData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoBsonData& operator=(ProtoBsonData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoBsonData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoBsonData* internal_default_instance() {
    return reinterpret_cast<const ProtoBsonData*>(
               &_ProtoBsonData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ProtoBsonData& a, ProtoBsonData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoBsonData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoBsonData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoBsonData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoBsonData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoBsonData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoBsonData& from) {
    ProtoBsonData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoBsonData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.ProtoBsonData";
  }
  protected:
  explicit ProtoBsonData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kVarStringFieldNumber = 7,
    kVarBinFieldNumber = 8,
    kDataTypeFieldNumber = 2,
    kVarInt32FieldNumber = 3,
    kVarInt64FieldNumber = 4,
    kVarDoubleFieldNumber = 5,
    kVarBoolFieldNumber = 6,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string var_string = 7;
  void clear_var_string();
  const std::string& var_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_string();
  PROTOBUF_NODISCARD std::string* release_var_string();
  void set_allocated_var_string(std::string* var_string);
  private:
  const std::string& _internal_var_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_string(const std::string& value);
  std::string* _internal_mutable_var_string();
  public:

  // bytes var_bin = 8;
  void clear_var_bin();
  const std::string& var_bin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_var_bin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_var_bin();
  PROTOBUF_NODISCARD std::string* release_var_bin();
  void set_allocated_var_bin(std::string* var_bin);
  private:
  const std::string& _internal_var_bin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_var_bin(const std::string& value);
  std::string* _internal_mutable_var_bin();
  public:

  // int32 data_type = 2;
  void clear_data_type();
  int32_t data_type() const;
  void set_data_type(int32_t value);
  private:
  int32_t _internal_data_type() const;
  void _internal_set_data_type(int32_t value);
  public:

  // int32 var_int32 = 3;
  void clear_var_int32();
  int32_t var_int32() const;
  void set_var_int32(int32_t value);
  private:
  int32_t _internal_var_int32() const;
  void _internal_set_var_int32(int32_t value);
  public:

  // int64 var_int64 = 4;
  void clear_var_int64();
  int64_t var_int64() const;
  void set_var_int64(int64_t value);
  private:
  int64_t _internal_var_int64() const;
  void _internal_set_var_int64(int64_t value);
  public:

  // double var_double = 5;
  void clear_var_double();
  double var_double() const;
  void set_var_double(double value);
  private:
  double _internal_var_double() const;
  void _internal_set_var_double(double value);
  public:

  // bool var_bool = 6;
  void clear_var_bool();
  bool var_bool() const;
  void set_var_bool(bool value);
  private:
  bool _internal_var_bool() const;
  void _internal_set_var_bool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.ProtoBsonData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr var_bin_;
    int32_t data_type_;
    int32_t var_int32_;
    int64_t var_int64_;
    double var_double_;
    bool var_bool_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class ProtoBsonObj final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.ProtoBsonObj) */ {
 public:
  inline ProtoBsonObj() : ProtoBsonObj(nullptr) {}
  ~ProtoBsonObj() override;
  explicit PROTOBUF_CONSTEXPR ProtoBsonObj(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoBsonObj(const ProtoBsonObj& from);
  ProtoBsonObj(ProtoBsonObj&& from) noexcept
    : ProtoBsonObj() {
    *this = ::std::move(from);
  }

  inline ProtoBsonObj& operator=(const ProtoBsonObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoBsonObj& operator=(ProtoBsonObj&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoBsonObj& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoBsonObj* internal_default_instance() {
    return reinterpret_cast<const ProtoBsonObj*>(
               &_ProtoBsonObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ProtoBsonObj& a, ProtoBsonObj& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoBsonObj* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoBsonObj* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoBsonObj* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoBsonObj>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoBsonObj& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoBsonObj& from) {
    ProtoBsonObj::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoBsonObj* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.ProtoBsonObj";
  }
  protected:
  explicit ProtoBsonObj(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBsonDataListFieldNumber = 1,
  };
  // repeated .S2S.ProtoBsonData bson_data_list = 1;
  int bson_data_list_size() const;
  private:
  int _internal_bson_data_list_size() const;
  public:
  void clear_bson_data_list();
  ::S2S::ProtoBsonData* mutable_bson_data_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonData >*
      mutable_bson_data_list();
  private:
  const ::S2S::ProtoBsonData& _internal_bson_data_list(int index) const;
  ::S2S::ProtoBsonData* _internal_add_bson_data_list();
  public:
  const ::S2S::ProtoBsonData& bson_data_list(int index) const;
  ::S2S::ProtoBsonData* add_bson_data_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonData >&
      bson_data_list() const;

  // @@protoc_insertion_point(class_scope:S2S.ProtoBsonObj)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonData > bson_data_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoUserData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoUserData) */ {
 public:
  inline MongoUserData() : MongoUserData(nullptr) {}
  ~MongoUserData() override;
  explicit PROTOBUF_CONSTEXPR MongoUserData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoUserData(const MongoUserData& from);
  MongoUserData(MongoUserData&& from) noexcept
    : MongoUserData() {
    *this = ::std::move(from);
  }

  inline MongoUserData& operator=(const MongoUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoUserData& operator=(MongoUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoUserData* internal_default_instance() {
    return reinterpret_cast<const MongoUserData*>(
               &_MongoUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MongoUserData& a, MongoUserData& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoUserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoUserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoUserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoUserData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoUserData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoUserData& from) {
    MongoUserData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoUserData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoUserData";
  }
  protected:
  explicit MongoUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringVar1FieldNumber = 6,
    kStringVar2FieldNumber = 7,
    kCmdFieldNumber = 1,
    kInt32Var1FieldNumber = 2,
    kInt64Var1FieldNumber = 4,
    kInt64Var2FieldNumber = 5,
    kInt32Var2FieldNumber = 3,
  };
  // string string_var1 = 6;
  void clear_string_var1();
  const std::string& string_var1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_var1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_var1();
  PROTOBUF_NODISCARD std::string* release_string_var1();
  void set_allocated_string_var1(std::string* string_var1);
  private:
  const std::string& _internal_string_var1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_var1(const std::string& value);
  std::string* _internal_mutable_string_var1();
  public:

  // string string_var2 = 7;
  void clear_string_var2();
  const std::string& string_var2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_var2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_var2();
  PROTOBUF_NODISCARD std::string* release_string_var2();
  void set_allocated_string_var2(std::string* string_var2);
  private:
  const std::string& _internal_string_var2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_var2(const std::string& value);
  std::string* _internal_mutable_string_var2();
  public:

  // int32 cmd = 1;
  void clear_cmd();
  int32_t cmd() const;
  void set_cmd(int32_t value);
  private:
  int32_t _internal_cmd() const;
  void _internal_set_cmd(int32_t value);
  public:

  // int32 int32_var1 = 2;
  void clear_int32_var1();
  int32_t int32_var1() const;
  void set_int32_var1(int32_t value);
  private:
  int32_t _internal_int32_var1() const;
  void _internal_set_int32_var1(int32_t value);
  public:

  // int64 int64_var1 = 4;
  void clear_int64_var1();
  int64_t int64_var1() const;
  void set_int64_var1(int64_t value);
  private:
  int64_t _internal_int64_var1() const;
  void _internal_set_int64_var1(int64_t value);
  public:

  // int64 int64_var2 = 5;
  void clear_int64_var2();
  int64_t int64_var2() const;
  void set_int64_var2(int64_t value);
  private:
  int64_t _internal_int64_var2() const;
  void _internal_set_int64_var2(int64_t value);
  public:

  // int32 int32_var2 = 3;
  void clear_int32_var2();
  int32_t int32_var2() const;
  void set_int32_var2(int32_t value);
  private:
  int32_t _internal_int32_var2() const;
  void _internal_set_int32_var2(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoUserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_var1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_var2_;
    int32_t cmd_;
    int32_t int32_var1_;
    int64_t int64_var1_;
    int64_t int64_var2_;
    int32_t int32_var2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoInsertReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoInsertReq) */ {
 public:
  inline MongoInsertReq() : MongoInsertReq(nullptr) {}
  ~MongoInsertReq() override;
  explicit PROTOBUF_CONSTEXPR MongoInsertReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoInsertReq(const MongoInsertReq& from);
  MongoInsertReq(MongoInsertReq&& from) noexcept
    : MongoInsertReq() {
    *this = ::std::move(from);
  }

  inline MongoInsertReq& operator=(const MongoInsertReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoInsertReq& operator=(MongoInsertReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoInsertReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoInsertReq* internal_default_instance() {
    return reinterpret_cast<const MongoInsertReq*>(
               &_MongoInsertReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MongoInsertReq& a, MongoInsertReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoInsertReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoInsertReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoInsertReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoInsertReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoInsertReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoInsertReq& from) {
    MongoInsertReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoInsertReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoInsertReq";
  }
  protected:
  explicit MongoInsertReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kDocFieldNumber = 3,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .S2S.ProtoBsonObj doc = 3;
  bool has_doc() const;
  private:
  bool _internal_has_doc() const;
  public:
  void clear_doc();
  const ::S2S::ProtoBsonObj& doc() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonObj* release_doc();
  ::S2S::ProtoBsonObj* mutable_doc();
  void set_allocated_doc(::S2S::ProtoBsonObj* doc);
  private:
  const ::S2S::ProtoBsonObj& _internal_doc() const;
  ::S2S::ProtoBsonObj* _internal_mutable_doc();
  public:
  void unsafe_arena_set_allocated_doc(
      ::S2S::ProtoBsonObj* doc);
  ::S2S::ProtoBsonObj* unsafe_arena_release_doc();

  // @@protoc_insertion_point(class_scope:S2S.MongoInsertReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::S2S::ProtoBsonObj* doc_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoInsertRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoInsertRes) */ {
 public:
  inline MongoInsertRes() : MongoInsertRes(nullptr) {}
  ~MongoInsertRes() override;
  explicit PROTOBUF_CONSTEXPR MongoInsertRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoInsertRes(const MongoInsertRes& from);
  MongoInsertRes(MongoInsertRes&& from) noexcept
    : MongoInsertRes() {
    *this = ::std::move(from);
  }

  inline MongoInsertRes& operator=(const MongoInsertRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoInsertRes& operator=(MongoInsertRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoInsertRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoInsertRes* internal_default_instance() {
    return reinterpret_cast<const MongoInsertRes*>(
               &_MongoInsertRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MongoInsertRes& a, MongoInsertRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoInsertRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoInsertRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoInsertRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoInsertRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoInsertRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoInsertRes& from) {
    MongoInsertRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoInsertRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoInsertRes";
  }
  protected:
  explicit MongoInsertRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .S2S.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::S2S::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::S2S::MongoUserData* release_user_data();
  ::S2S::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::S2S::MongoUserData* user_data);
  private:
  const ::S2S::MongoUserData& _internal_user_data() const;
  ::S2S::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::S2S::MongoUserData* user_data);
  ::S2S::MongoUserData* unsafe_arena_release_user_data();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoInsertRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::S2S::MongoUserData* user_data_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoRemoveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoRemoveReq) */ {
 public:
  inline MongoRemoveReq() : MongoRemoveReq(nullptr) {}
  ~MongoRemoveReq() override;
  explicit PROTOBUF_CONSTEXPR MongoRemoveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoRemoveReq(const MongoRemoveReq& from);
  MongoRemoveReq(MongoRemoveReq&& from) noexcept
    : MongoRemoveReq() {
    *this = ::std::move(from);
  }

  inline MongoRemoveReq& operator=(const MongoRemoveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoRemoveReq& operator=(MongoRemoveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoRemoveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoRemoveReq* internal_default_instance() {
    return reinterpret_cast<const MongoRemoveReq*>(
               &_MongoRemoveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MongoRemoveReq& a, MongoRemoveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoRemoveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoRemoveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoRemoveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoRemoveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoRemoveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoRemoveReq& from) {
    MongoRemoveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoRemoveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoRemoveReq";
  }
  protected:
  explicit MongoRemoveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kSelectorFieldNumber = 3,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .S2S.ProtoBsonObj selector = 3;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::S2S::ProtoBsonObj& selector() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonObj* release_selector();
  ::S2S::ProtoBsonObj* mutable_selector();
  void set_allocated_selector(::S2S::ProtoBsonObj* selector);
  private:
  const ::S2S::ProtoBsonObj& _internal_selector() const;
  ::S2S::ProtoBsonObj* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::S2S::ProtoBsonObj* selector);
  ::S2S::ProtoBsonObj* unsafe_arena_release_selector();

  // @@protoc_insertion_point(class_scope:S2S.MongoRemoveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::S2S::ProtoBsonObj* selector_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoRemoveRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoRemoveRes) */ {
 public:
  inline MongoRemoveRes() : MongoRemoveRes(nullptr) {}
  ~MongoRemoveRes() override;
  explicit PROTOBUF_CONSTEXPR MongoRemoveRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoRemoveRes(const MongoRemoveRes& from);
  MongoRemoveRes(MongoRemoveRes&& from) noexcept
    : MongoRemoveRes() {
    *this = ::std::move(from);
  }

  inline MongoRemoveRes& operator=(const MongoRemoveRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoRemoveRes& operator=(MongoRemoveRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoRemoveRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoRemoveRes* internal_default_instance() {
    return reinterpret_cast<const MongoRemoveRes*>(
               &_MongoRemoveRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MongoRemoveRes& a, MongoRemoveRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoRemoveRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoRemoveRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoRemoveRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoRemoveRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoRemoveRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoRemoveRes& from) {
    MongoRemoveRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoRemoveRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoRemoveRes";
  }
  protected:
  explicit MongoRemoveRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .S2S.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::S2S::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::S2S::MongoUserData* release_user_data();
  ::S2S::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::S2S::MongoUserData* user_data);
  private:
  const ::S2S::MongoUserData& _internal_user_data() const;
  ::S2S::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::S2S::MongoUserData* user_data);
  ::S2S::MongoUserData* unsafe_arena_release_user_data();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoRemoveRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::S2S::MongoUserData* user_data_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoSaveReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoSaveReq) */ {
 public:
  inline MongoSaveReq() : MongoSaveReq(nullptr) {}
  ~MongoSaveReq() override;
  explicit PROTOBUF_CONSTEXPR MongoSaveReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoSaveReq(const MongoSaveReq& from);
  MongoSaveReq(MongoSaveReq&& from) noexcept
    : MongoSaveReq() {
    *this = ::std::move(from);
  }

  inline MongoSaveReq& operator=(const MongoSaveReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoSaveReq& operator=(MongoSaveReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoSaveReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoSaveReq* internal_default_instance() {
    return reinterpret_cast<const MongoSaveReq*>(
               &_MongoSaveReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MongoSaveReq& a, MongoSaveReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoSaveReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoSaveReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoSaveReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoSaveReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoSaveReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoSaveReq& from) {
    MongoSaveReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoSaveReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoSaveReq";
  }
  protected:
  explicit MongoSaveReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kSelectorFieldNumber = 3,
    kUpdatorFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .S2S.ProtoBsonObj selector = 3;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::S2S::ProtoBsonObj& selector() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonObj* release_selector();
  ::S2S::ProtoBsonObj* mutable_selector();
  void set_allocated_selector(::S2S::ProtoBsonObj* selector);
  private:
  const ::S2S::ProtoBsonObj& _internal_selector() const;
  ::S2S::ProtoBsonObj* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::S2S::ProtoBsonObj* selector);
  ::S2S::ProtoBsonObj* unsafe_arena_release_selector();

  // .S2S.ProtoBsonObj updator = 4;
  bool has_updator() const;
  private:
  bool _internal_has_updator() const;
  public:
  void clear_updator();
  const ::S2S::ProtoBsonObj& updator() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonObj* release_updator();
  ::S2S::ProtoBsonObj* mutable_updator();
  void set_allocated_updator(::S2S::ProtoBsonObj* updator);
  private:
  const ::S2S::ProtoBsonObj& _internal_updator() const;
  ::S2S::ProtoBsonObj* _internal_mutable_updator();
  public:
  void unsafe_arena_set_allocated_updator(
      ::S2S::ProtoBsonObj* updator);
  ::S2S::ProtoBsonObj* unsafe_arena_release_updator();

  // @@protoc_insertion_point(class_scope:S2S.MongoSaveReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::S2S::ProtoBsonObj* selector_;
    ::S2S::ProtoBsonObj* updator_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoSaveRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoSaveRes) */ {
 public:
  inline MongoSaveRes() : MongoSaveRes(nullptr) {}
  ~MongoSaveRes() override;
  explicit PROTOBUF_CONSTEXPR MongoSaveRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoSaveRes(const MongoSaveRes& from);
  MongoSaveRes(MongoSaveRes&& from) noexcept
    : MongoSaveRes() {
    *this = ::std::move(from);
  }

  inline MongoSaveRes& operator=(const MongoSaveRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoSaveRes& operator=(MongoSaveRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoSaveRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoSaveRes* internal_default_instance() {
    return reinterpret_cast<const MongoSaveRes*>(
               &_MongoSaveRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MongoSaveRes& a, MongoSaveRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoSaveRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoSaveRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoSaveRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoSaveRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoSaveRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoSaveRes& from) {
    MongoSaveRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoSaveRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoSaveRes";
  }
  protected:
  explicit MongoSaveRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // .S2S.MongoUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::S2S::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::S2S::MongoUserData* release_user_data();
  ::S2S::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::S2S::MongoUserData* user_data);
  private:
  const ::S2S::MongoUserData& _internal_user_data() const;
  ::S2S::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::S2S::MongoUserData* user_data);
  ::S2S::MongoUserData* unsafe_arena_release_user_data();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoSaveRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::S2S::MongoUserData* user_data_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoFindReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoFindReq) */ {
 public:
  inline MongoFindReq() : MongoFindReq(nullptr) {}
  ~MongoFindReq() override;
  explicit PROTOBUF_CONSTEXPR MongoFindReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoFindReq(const MongoFindReq& from);
  MongoFindReq(MongoFindReq&& from) noexcept
    : MongoFindReq() {
    *this = ::std::move(from);
  }

  inline MongoFindReq& operator=(const MongoFindReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoFindReq& operator=(MongoFindReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoFindReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoFindReq* internal_default_instance() {
    return reinterpret_cast<const MongoFindReq*>(
               &_MongoFindReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MongoFindReq& a, MongoFindReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoFindReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoFindReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoFindReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoFindReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoFindReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoFindReq& from) {
    MongoFindReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoFindReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoFindReq";
  }
  protected:
  explicit MongoFindReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kSelectorFieldNumber = 3,
    kSkipFieldNumber = 4,
    kLimitFieldNumber = 5,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .S2S.ProtoBsonObj selector = 3;
  bool has_selector() const;
  private:
  bool _internal_has_selector() const;
  public:
  void clear_selector();
  const ::S2S::ProtoBsonObj& selector() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonObj* release_selector();
  ::S2S::ProtoBsonObj* mutable_selector();
  void set_allocated_selector(::S2S::ProtoBsonObj* selector);
  private:
  const ::S2S::ProtoBsonObj& _internal_selector() const;
  ::S2S::ProtoBsonObj* _internal_mutable_selector();
  public:
  void unsafe_arena_set_allocated_selector(
      ::S2S::ProtoBsonObj* selector);
  ::S2S::ProtoBsonObj* unsafe_arena_release_selector();

  // int32 skip = 4;
  void clear_skip();
  int32_t skip() const;
  void set_skip(int32_t value);
  private:
  int32_t _internal_skip() const;
  void _internal_set_skip(int32_t value);
  public:

  // int32 limit = 5;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoFindReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::S2S::ProtoBsonObj* selector_;
    int32_t skip_;
    int32_t limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoFindRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoFindRes) */ {
 public:
  inline MongoFindRes() : MongoFindRes(nullptr) {}
  ~MongoFindRes() override;
  explicit PROTOBUF_CONSTEXPR MongoFindRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoFindRes(const MongoFindRes& from);
  MongoFindRes(MongoFindRes&& from) noexcept
    : MongoFindRes() {
    *this = ::std::move(from);
  }

  inline MongoFindRes& operator=(const MongoFindRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoFindRes& operator=(MongoFindRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoFindRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoFindRes* internal_default_instance() {
    return reinterpret_cast<const MongoFindRes*>(
               &_MongoFindRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MongoFindRes& a, MongoFindRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoFindRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoFindRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoFindRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoFindRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoFindRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoFindRes& from) {
    MongoFindRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoFindRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoFindRes";
  }
  protected:
  explicit MongoFindRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 2,
    kUserDataFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // repeated .S2S.ProtoBsonObj data_list = 2;
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;
  public:
  void clear_data_list();
  ::S2S::ProtoBsonObj* mutable_data_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >*
      mutable_data_list();
  private:
  const ::S2S::ProtoBsonObj& _internal_data_list(int index) const;
  ::S2S::ProtoBsonObj* _internal_add_data_list();
  public:
  const ::S2S::ProtoBsonObj& data_list(int index) const;
  ::S2S::ProtoBsonObj* add_data_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >&
      data_list() const;

  // .S2S.MongoUserData user_data = 3;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::S2S::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::S2S::MongoUserData* release_user_data();
  ::S2S::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::S2S::MongoUserData* user_data);
  private:
  const ::S2S::MongoUserData& _internal_user_data() const;
  ::S2S::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::S2S::MongoUserData* user_data);
  ::S2S::MongoUserData* unsafe_arena_release_user_data();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoFindRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj > data_list_;
    ::S2S::MongoUserData* user_data_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class ProtoBsonBatchFindData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.ProtoBsonBatchFindData) */ {
 public:
  inline ProtoBsonBatchFindData() : ProtoBsonBatchFindData(nullptr) {}
  ~ProtoBsonBatchFindData() override;
  explicit PROTOBUF_CONSTEXPR ProtoBsonBatchFindData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtoBsonBatchFindData(const ProtoBsonBatchFindData& from);
  ProtoBsonBatchFindData(ProtoBsonBatchFindData&& from) noexcept
    : ProtoBsonBatchFindData() {
    *this = ::std::move(from);
  }

  inline ProtoBsonBatchFindData& operator=(const ProtoBsonBatchFindData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtoBsonBatchFindData& operator=(ProtoBsonBatchFindData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtoBsonBatchFindData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtoBsonBatchFindData* internal_default_instance() {
    return reinterpret_cast<const ProtoBsonBatchFindData*>(
               &_ProtoBsonBatchFindData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ProtoBsonBatchFindData& a, ProtoBsonBatchFindData& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtoBsonBatchFindData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtoBsonBatchFindData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProtoBsonBatchFindData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProtoBsonBatchFindData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtoBsonBatchFindData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProtoBsonBatchFindData& from) {
    ProtoBsonBatchFindData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtoBsonBatchFindData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.ProtoBsonBatchFindData";
  }
  protected:
  explicit ProtoBsonBatchFindData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInt32VarListFieldNumber = 3,
    kInt64VarListFieldNumber = 4,
    kStringVarListFieldNumber = 5,
    kKeyFieldNumber = 1,
    kDataTypeFieldNumber = 2,
  };
  // repeated int32 int32_var_list = 3;
  int int32_var_list_size() const;
  private:
  int _internal_int32_var_list_size() const;
  public:
  void clear_int32_var_list();
  private:
  int32_t _internal_int32_var_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_int32_var_list() const;
  void _internal_add_int32_var_list(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_int32_var_list();
  public:
  int32_t int32_var_list(int index) const;
  void set_int32_var_list(int index, int32_t value);
  void add_int32_var_list(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      int32_var_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_int32_var_list();

  // repeated int64 int64_var_list = 4;
  int int64_var_list_size() const;
  private:
  int _internal_int64_var_list_size() const;
  public:
  void clear_int64_var_list();
  private:
  int64_t _internal_int64_var_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_int64_var_list() const;
  void _internal_add_int64_var_list(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_int64_var_list();
  public:
  int64_t int64_var_list(int index) const;
  void set_int64_var_list(int index, int64_t value);
  void add_int64_var_list(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      int64_var_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_int64_var_list();

  // repeated string string_var_list = 5;
  int string_var_list_size() const;
  private:
  int _internal_string_var_list_size() const;
  public:
  void clear_string_var_list();
  const std::string& string_var_list(int index) const;
  std::string* mutable_string_var_list(int index);
  void set_string_var_list(int index, const std::string& value);
  void set_string_var_list(int index, std::string&& value);
  void set_string_var_list(int index, const char* value);
  void set_string_var_list(int index, const char* value, size_t size);
  std::string* add_string_var_list();
  void add_string_var_list(const std::string& value);
  void add_string_var_list(std::string&& value);
  void add_string_var_list(const char* value);
  void add_string_var_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_var_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_var_list();
  private:
  const std::string& _internal_string_var_list(int index) const;
  std::string* _internal_add_string_var_list();
  public:

  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int32 data_type = 2;
  void clear_data_type();
  int32_t data_type() const;
  void set_data_type(int32_t value);
  private:
  int32_t _internal_data_type() const;
  void _internal_set_data_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.ProtoBsonBatchFindData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > int32_var_list_;
    mutable std::atomic<int> _int32_var_list_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > int64_var_list_;
    mutable std::atomic<int> _int64_var_list_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_var_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    int32_t data_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoBatchFindReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoBatchFindReq) */ {
 public:
  inline MongoBatchFindReq() : MongoBatchFindReq(nullptr) {}
  ~MongoBatchFindReq() override;
  explicit PROTOBUF_CONSTEXPR MongoBatchFindReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoBatchFindReq(const MongoBatchFindReq& from);
  MongoBatchFindReq(MongoBatchFindReq&& from) noexcept
    : MongoBatchFindReq() {
    *this = ::std::move(from);
  }

  inline MongoBatchFindReq& operator=(const MongoBatchFindReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoBatchFindReq& operator=(MongoBatchFindReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoBatchFindReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoBatchFindReq* internal_default_instance() {
    return reinterpret_cast<const MongoBatchFindReq*>(
               &_MongoBatchFindReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MongoBatchFindReq& a, MongoBatchFindReq& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoBatchFindReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoBatchFindReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoBatchFindReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoBatchFindReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoBatchFindReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoBatchFindReq& from) {
    MongoBatchFindReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoBatchFindReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoBatchFindReq";
  }
  protected:
  explicit MongoBatchFindReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kColNameFieldNumber = 2,
    kQueryFieldNumber = 3,
    kFieldsFieldNumber = 4,
    kLogicBatchNumFieldNumber = 5,
    kSkipFieldNumber = 6,
    kLimitFieldNumber = 7,
    kBatchSizeFieldNumber = 8,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string col_name = 2;
  void clear_col_name();
  const std::string& col_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col_name();
  PROTOBUF_NODISCARD std::string* release_col_name();
  void set_allocated_col_name(std::string* col_name);
  private:
  const std::string& _internal_col_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col_name(const std::string& value);
  std::string* _internal_mutable_col_name();
  public:

  // .S2S.ProtoBsonBatchFindData query = 3;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  const ::S2S::ProtoBsonBatchFindData& query() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonBatchFindData* release_query();
  ::S2S::ProtoBsonBatchFindData* mutable_query();
  void set_allocated_query(::S2S::ProtoBsonBatchFindData* query);
  private:
  const ::S2S::ProtoBsonBatchFindData& _internal_query() const;
  ::S2S::ProtoBsonBatchFindData* _internal_mutable_query();
  public:
  void unsafe_arena_set_allocated_query(
      ::S2S::ProtoBsonBatchFindData* query);
  ::S2S::ProtoBsonBatchFindData* unsafe_arena_release_query();

  // .S2S.ProtoBsonObj fields = 4;
  bool has_fields() const;
  private:
  bool _internal_has_fields() const;
  public:
  void clear_fields();
  const ::S2S::ProtoBsonObj& fields() const;
  PROTOBUF_NODISCARD ::S2S::ProtoBsonObj* release_fields();
  ::S2S::ProtoBsonObj* mutable_fields();
  void set_allocated_fields(::S2S::ProtoBsonObj* fields);
  private:
  const ::S2S::ProtoBsonObj& _internal_fields() const;
  ::S2S::ProtoBsonObj* _internal_mutable_fields();
  public:
  void unsafe_arena_set_allocated_fields(
      ::S2S::ProtoBsonObj* fields);
  ::S2S::ProtoBsonObj* unsafe_arena_release_fields();

  // int32 logic_batch_num = 5;
  void clear_logic_batch_num();
  int32_t logic_batch_num() const;
  void set_logic_batch_num(int32_t value);
  private:
  int32_t _internal_logic_batch_num() const;
  void _internal_set_logic_batch_num(int32_t value);
  public:

  // int32 skip = 6;
  void clear_skip();
  int32_t skip() const;
  void set_skip(int32_t value);
  private:
  int32_t _internal_skip() const;
  void _internal_set_skip(int32_t value);
  public:

  // int32 limit = 7;
  void clear_limit();
  int32_t limit() const;
  void set_limit(int32_t value);
  private:
  int32_t _internal_limit() const;
  void _internal_set_limit(int32_t value);
  public:

  // int32 batch_size = 8;
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoBatchFindReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_name_;
    ::S2S::ProtoBsonBatchFindData* query_;
    ::S2S::ProtoBsonObj* fields_;
    int32_t logic_batch_num_;
    int32_t skip_;
    int32_t limit_;
    int32_t batch_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoBatchFindRes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoBatchFindRes) */ {
 public:
  inline MongoBatchFindRes() : MongoBatchFindRes(nullptr) {}
  ~MongoBatchFindRes() override;
  explicit PROTOBUF_CONSTEXPR MongoBatchFindRes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoBatchFindRes(const MongoBatchFindRes& from);
  MongoBatchFindRes(MongoBatchFindRes&& from) noexcept
    : MongoBatchFindRes() {
    *this = ::std::move(from);
  }

  inline MongoBatchFindRes& operator=(const MongoBatchFindRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoBatchFindRes& operator=(MongoBatchFindRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoBatchFindRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoBatchFindRes* internal_default_instance() {
    return reinterpret_cast<const MongoBatchFindRes*>(
               &_MongoBatchFindRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MongoBatchFindRes& a, MongoBatchFindRes& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoBatchFindRes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoBatchFindRes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoBatchFindRes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoBatchFindRes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoBatchFindRes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoBatchFindRes& from) {
    MongoBatchFindRes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoBatchFindRes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoBatchFindRes";
  }
  protected:
  explicit MongoBatchFindRes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 3,
    kUserDataFieldNumber = 4,
    kSuccessFieldNumber = 1,
    kHasMoreFieldNumber = 2,
  };
  // repeated .S2S.ProtoBsonObj data_list = 3;
  int data_list_size() const;
  private:
  int _internal_data_list_size() const;
  public:
  void clear_data_list();
  ::S2S::ProtoBsonObj* mutable_data_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >*
      mutable_data_list();
  private:
  const ::S2S::ProtoBsonObj& _internal_data_list(int index) const;
  ::S2S::ProtoBsonObj* _internal_add_data_list();
  public:
  const ::S2S::ProtoBsonObj& data_list(int index) const;
  ::S2S::ProtoBsonObj* add_data_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >&
      data_list() const;

  // .S2S.MongoUserData user_data = 4;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::S2S::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::S2S::MongoUserData* release_user_data();
  ::S2S::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::S2S::MongoUserData* user_data);
  private:
  const ::S2S::MongoUserData& _internal_user_data() const;
  ::S2S::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::S2S::MongoUserData* user_data);
  ::S2S::MongoUserData* unsafe_arena_release_user_data();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool has_more = 2;
  void clear_has_more();
  bool has_more() const;
  void set_has_more(bool value);
  private:
  bool _internal_has_more() const;
  void _internal_set_has_more(bool value);
  public:

  // @@protoc_insertion_point(class_scope:S2S.MongoBatchFindRes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj > data_list_;
    ::S2S::MongoUserData* user_data_;
    bool success_;
    bool has_more_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// -------------------------------------------------------------------

class MongoDBMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:S2S.MongoDBMsg) */ {
 public:
  inline MongoDBMsg() : MongoDBMsg(nullptr) {}
  ~MongoDBMsg() override;
  explicit PROTOBUF_CONSTEXPR MongoDBMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MongoDBMsg(const MongoDBMsg& from);
  MongoDBMsg(MongoDBMsg&& from) noexcept
    : MongoDBMsg() {
    *this = ::std::move(from);
  }

  inline MongoDBMsg& operator=(const MongoDBMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline MongoDBMsg& operator=(MongoDBMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MongoDBMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const MongoDBMsg* internal_default_instance() {
    return reinterpret_cast<const MongoDBMsg*>(
               &_MongoDBMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MongoDBMsg& a, MongoDBMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(MongoDBMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MongoDBMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MongoDBMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MongoDBMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MongoDBMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MongoDBMsg& from) {
    MongoDBMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MongoDBMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "S2S.MongoDBMsg";
  }
  protected:
  explicit MongoDBMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 1,
    kInsertReqFieldNumber = 2,
    kInsertResFieldNumber = 3,
    kRemoveReqFieldNumber = 4,
    kRemoveResFieldNumber = 5,
    kSaveReqFieldNumber = 6,
    kSaveResFieldNumber = 7,
    kFindReqFieldNumber = 10,
    kFindResFieldNumber = 11,
    kBatchFindReqFieldNumber = 12,
    kBatchFindResFieldNumber = 13,
  };
  // .S2S.MongoUserData user_data = 1;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::S2S::MongoUserData& user_data() const;
  PROTOBUF_NODISCARD ::S2S::MongoUserData* release_user_data();
  ::S2S::MongoUserData* mutable_user_data();
  void set_allocated_user_data(::S2S::MongoUserData* user_data);
  private:
  const ::S2S::MongoUserData& _internal_user_data() const;
  ::S2S::MongoUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::S2S::MongoUserData* user_data);
  ::S2S::MongoUserData* unsafe_arena_release_user_data();

  // .S2S.MongoInsertReq insert_req = 2;
  bool has_insert_req() const;
  private:
  bool _internal_has_insert_req() const;
  public:
  void clear_insert_req();
  const ::S2S::MongoInsertReq& insert_req() const;
  PROTOBUF_NODISCARD ::S2S::MongoInsertReq* release_insert_req();
  ::S2S::MongoInsertReq* mutable_insert_req();
  void set_allocated_insert_req(::S2S::MongoInsertReq* insert_req);
  private:
  const ::S2S::MongoInsertReq& _internal_insert_req() const;
  ::S2S::MongoInsertReq* _internal_mutable_insert_req();
  public:
  void unsafe_arena_set_allocated_insert_req(
      ::S2S::MongoInsertReq* insert_req);
  ::S2S::MongoInsertReq* unsafe_arena_release_insert_req();

  // .S2S.MongoInsertRes insert_res = 3;
  bool has_insert_res() const;
  private:
  bool _internal_has_insert_res() const;
  public:
  void clear_insert_res();
  const ::S2S::MongoInsertRes& insert_res() const;
  PROTOBUF_NODISCARD ::S2S::MongoInsertRes* release_insert_res();
  ::S2S::MongoInsertRes* mutable_insert_res();
  void set_allocated_insert_res(::S2S::MongoInsertRes* insert_res);
  private:
  const ::S2S::MongoInsertRes& _internal_insert_res() const;
  ::S2S::MongoInsertRes* _internal_mutable_insert_res();
  public:
  void unsafe_arena_set_allocated_insert_res(
      ::S2S::MongoInsertRes* insert_res);
  ::S2S::MongoInsertRes* unsafe_arena_release_insert_res();

  // .S2S.MongoRemoveReq remove_req = 4;
  bool has_remove_req() const;
  private:
  bool _internal_has_remove_req() const;
  public:
  void clear_remove_req();
  const ::S2S::MongoRemoveReq& remove_req() const;
  PROTOBUF_NODISCARD ::S2S::MongoRemoveReq* release_remove_req();
  ::S2S::MongoRemoveReq* mutable_remove_req();
  void set_allocated_remove_req(::S2S::MongoRemoveReq* remove_req);
  private:
  const ::S2S::MongoRemoveReq& _internal_remove_req() const;
  ::S2S::MongoRemoveReq* _internal_mutable_remove_req();
  public:
  void unsafe_arena_set_allocated_remove_req(
      ::S2S::MongoRemoveReq* remove_req);
  ::S2S::MongoRemoveReq* unsafe_arena_release_remove_req();

  // .S2S.MongoRemoveRes remove_res = 5;
  bool has_remove_res() const;
  private:
  bool _internal_has_remove_res() const;
  public:
  void clear_remove_res();
  const ::S2S::MongoRemoveRes& remove_res() const;
  PROTOBUF_NODISCARD ::S2S::MongoRemoveRes* release_remove_res();
  ::S2S::MongoRemoveRes* mutable_remove_res();
  void set_allocated_remove_res(::S2S::MongoRemoveRes* remove_res);
  private:
  const ::S2S::MongoRemoveRes& _internal_remove_res() const;
  ::S2S::MongoRemoveRes* _internal_mutable_remove_res();
  public:
  void unsafe_arena_set_allocated_remove_res(
      ::S2S::MongoRemoveRes* remove_res);
  ::S2S::MongoRemoveRes* unsafe_arena_release_remove_res();

  // .S2S.MongoSaveReq save_req = 6;
  bool has_save_req() const;
  private:
  bool _internal_has_save_req() const;
  public:
  void clear_save_req();
  const ::S2S::MongoSaveReq& save_req() const;
  PROTOBUF_NODISCARD ::S2S::MongoSaveReq* release_save_req();
  ::S2S::MongoSaveReq* mutable_save_req();
  void set_allocated_save_req(::S2S::MongoSaveReq* save_req);
  private:
  const ::S2S::MongoSaveReq& _internal_save_req() const;
  ::S2S::MongoSaveReq* _internal_mutable_save_req();
  public:
  void unsafe_arena_set_allocated_save_req(
      ::S2S::MongoSaveReq* save_req);
  ::S2S::MongoSaveReq* unsafe_arena_release_save_req();

  // .S2S.MongoSaveRes save_res = 7;
  bool has_save_res() const;
  private:
  bool _internal_has_save_res() const;
  public:
  void clear_save_res();
  const ::S2S::MongoSaveRes& save_res() const;
  PROTOBUF_NODISCARD ::S2S::MongoSaveRes* release_save_res();
  ::S2S::MongoSaveRes* mutable_save_res();
  void set_allocated_save_res(::S2S::MongoSaveRes* save_res);
  private:
  const ::S2S::MongoSaveRes& _internal_save_res() const;
  ::S2S::MongoSaveRes* _internal_mutable_save_res();
  public:
  void unsafe_arena_set_allocated_save_res(
      ::S2S::MongoSaveRes* save_res);
  ::S2S::MongoSaveRes* unsafe_arena_release_save_res();

  // .S2S.MongoFindReq find_req = 10;
  bool has_find_req() const;
  private:
  bool _internal_has_find_req() const;
  public:
  void clear_find_req();
  const ::S2S::MongoFindReq& find_req() const;
  PROTOBUF_NODISCARD ::S2S::MongoFindReq* release_find_req();
  ::S2S::MongoFindReq* mutable_find_req();
  void set_allocated_find_req(::S2S::MongoFindReq* find_req);
  private:
  const ::S2S::MongoFindReq& _internal_find_req() const;
  ::S2S::MongoFindReq* _internal_mutable_find_req();
  public:
  void unsafe_arena_set_allocated_find_req(
      ::S2S::MongoFindReq* find_req);
  ::S2S::MongoFindReq* unsafe_arena_release_find_req();

  // .S2S.MongoFindRes find_res = 11;
  bool has_find_res() const;
  private:
  bool _internal_has_find_res() const;
  public:
  void clear_find_res();
  const ::S2S::MongoFindRes& find_res() const;
  PROTOBUF_NODISCARD ::S2S::MongoFindRes* release_find_res();
  ::S2S::MongoFindRes* mutable_find_res();
  void set_allocated_find_res(::S2S::MongoFindRes* find_res);
  private:
  const ::S2S::MongoFindRes& _internal_find_res() const;
  ::S2S::MongoFindRes* _internal_mutable_find_res();
  public:
  void unsafe_arena_set_allocated_find_res(
      ::S2S::MongoFindRes* find_res);
  ::S2S::MongoFindRes* unsafe_arena_release_find_res();

  // .S2S.MongoBatchFindReq batch_find_req = 12;
  bool has_batch_find_req() const;
  private:
  bool _internal_has_batch_find_req() const;
  public:
  void clear_batch_find_req();
  const ::S2S::MongoBatchFindReq& batch_find_req() const;
  PROTOBUF_NODISCARD ::S2S::MongoBatchFindReq* release_batch_find_req();
  ::S2S::MongoBatchFindReq* mutable_batch_find_req();
  void set_allocated_batch_find_req(::S2S::MongoBatchFindReq* batch_find_req);
  private:
  const ::S2S::MongoBatchFindReq& _internal_batch_find_req() const;
  ::S2S::MongoBatchFindReq* _internal_mutable_batch_find_req();
  public:
  void unsafe_arena_set_allocated_batch_find_req(
      ::S2S::MongoBatchFindReq* batch_find_req);
  ::S2S::MongoBatchFindReq* unsafe_arena_release_batch_find_req();

  // .S2S.MongoBatchFindRes batch_find_res = 13;
  bool has_batch_find_res() const;
  private:
  bool _internal_has_batch_find_res() const;
  public:
  void clear_batch_find_res();
  const ::S2S::MongoBatchFindRes& batch_find_res() const;
  PROTOBUF_NODISCARD ::S2S::MongoBatchFindRes* release_batch_find_res();
  ::S2S::MongoBatchFindRes* mutable_batch_find_res();
  void set_allocated_batch_find_res(::S2S::MongoBatchFindRes* batch_find_res);
  private:
  const ::S2S::MongoBatchFindRes& _internal_batch_find_res() const;
  ::S2S::MongoBatchFindRes* _internal_mutable_batch_find_res();
  public:
  void unsafe_arena_set_allocated_batch_find_res(
      ::S2S::MongoBatchFindRes* batch_find_res);
  ::S2S::MongoBatchFindRes* unsafe_arena_release_batch_find_res();

  // @@protoc_insertion_point(class_scope:S2S.MongoDBMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::S2S::MongoUserData* user_data_;
    ::S2S::MongoInsertReq* insert_req_;
    ::S2S::MongoInsertRes* insert_res_;
    ::S2S::MongoRemoveReq* remove_req_;
    ::S2S::MongoRemoveRes* remove_res_;
    ::S2S::MongoSaveReq* save_req_;
    ::S2S::MongoSaveRes* save_res_;
    ::S2S::MongoFindReq* find_req_;
    ::S2S::MongoFindRes* find_res_;
    ::S2S::MongoBatchFindReq* batch_find_req_;
    ::S2S::MongoBatchFindRes* batch_find_res_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_5fmongo_5fproxy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProtoBsonData

// string key = 1;
inline void ProtoBsonData::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProtoBsonData::key() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonData::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.key)
}
inline std::string* ProtoBsonData::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:S2S.ProtoBsonData.key)
  return _s;
}
inline const std::string& ProtoBsonData::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ProtoBsonData::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonData::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonData::release_key() {
  // @@protoc_insertion_point(field_release:S2S.ProtoBsonData.key)
  return _impl_.key_.Release();
}
inline void ProtoBsonData::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.ProtoBsonData.key)
}

// int32 data_type = 2;
inline void ProtoBsonData::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline int32_t ProtoBsonData::_internal_data_type() const {
  return _impl_.data_type_;
}
inline int32_t ProtoBsonData::data_type() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.data_type)
  return _internal_data_type();
}
inline void ProtoBsonData::_internal_set_data_type(int32_t value) {
  
  _impl_.data_type_ = value;
}
inline void ProtoBsonData::set_data_type(int32_t value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.data_type)
}

// int32 var_int32 = 3;
inline void ProtoBsonData::clear_var_int32() {
  _impl_.var_int32_ = 0;
}
inline int32_t ProtoBsonData::_internal_var_int32() const {
  return _impl_.var_int32_;
}
inline int32_t ProtoBsonData::var_int32() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.var_int32)
  return _internal_var_int32();
}
inline void ProtoBsonData::_internal_set_var_int32(int32_t value) {
  
  _impl_.var_int32_ = value;
}
inline void ProtoBsonData::set_var_int32(int32_t value) {
  _internal_set_var_int32(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.var_int32)
}

// int64 var_int64 = 4;
inline void ProtoBsonData::clear_var_int64() {
  _impl_.var_int64_ = int64_t{0};
}
inline int64_t ProtoBsonData::_internal_var_int64() const {
  return _impl_.var_int64_;
}
inline int64_t ProtoBsonData::var_int64() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.var_int64)
  return _internal_var_int64();
}
inline void ProtoBsonData::_internal_set_var_int64(int64_t value) {
  
  _impl_.var_int64_ = value;
}
inline void ProtoBsonData::set_var_int64(int64_t value) {
  _internal_set_var_int64(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.var_int64)
}

// double var_double = 5;
inline void ProtoBsonData::clear_var_double() {
  _impl_.var_double_ = 0;
}
inline double ProtoBsonData::_internal_var_double() const {
  return _impl_.var_double_;
}
inline double ProtoBsonData::var_double() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.var_double)
  return _internal_var_double();
}
inline void ProtoBsonData::_internal_set_var_double(double value) {
  
  _impl_.var_double_ = value;
}
inline void ProtoBsonData::set_var_double(double value) {
  _internal_set_var_double(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.var_double)
}

// bool var_bool = 6;
inline void ProtoBsonData::clear_var_bool() {
  _impl_.var_bool_ = false;
}
inline bool ProtoBsonData::_internal_var_bool() const {
  return _impl_.var_bool_;
}
inline bool ProtoBsonData::var_bool() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.var_bool)
  return _internal_var_bool();
}
inline void ProtoBsonData::_internal_set_var_bool(bool value) {
  
  _impl_.var_bool_ = value;
}
inline void ProtoBsonData::set_var_bool(bool value) {
  _internal_set_var_bool(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.var_bool)
}

// string var_string = 7;
inline void ProtoBsonData::clear_var_string() {
  _impl_.var_string_.ClearToEmpty();
}
inline const std::string& ProtoBsonData::var_string() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.var_string)
  return _internal_var_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonData::set_var_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.var_string)
}
inline std::string* ProtoBsonData::mutable_var_string() {
  std::string* _s = _internal_mutable_var_string();
  // @@protoc_insertion_point(field_mutable:S2S.ProtoBsonData.var_string)
  return _s;
}
inline const std::string& ProtoBsonData::_internal_var_string() const {
  return _impl_.var_string_.Get();
}
inline void ProtoBsonData::_internal_set_var_string(const std::string& value) {
  
  _impl_.var_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonData::_internal_mutable_var_string() {
  
  return _impl_.var_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonData::release_var_string() {
  // @@protoc_insertion_point(field_release:S2S.ProtoBsonData.var_string)
  return _impl_.var_string_.Release();
}
inline void ProtoBsonData::set_allocated_var_string(std::string* var_string) {
  if (var_string != nullptr) {
    
  } else {
    
  }
  _impl_.var_string_.SetAllocated(var_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_string_.IsDefault()) {
    _impl_.var_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.ProtoBsonData.var_string)
}

// bytes var_bin = 8;
inline void ProtoBsonData::clear_var_bin() {
  _impl_.var_bin_.ClearToEmpty();
}
inline const std::string& ProtoBsonData::var_bin() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonData.var_bin)
  return _internal_var_bin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonData::set_var_bin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.var_bin_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonData.var_bin)
}
inline std::string* ProtoBsonData::mutable_var_bin() {
  std::string* _s = _internal_mutable_var_bin();
  // @@protoc_insertion_point(field_mutable:S2S.ProtoBsonData.var_bin)
  return _s;
}
inline const std::string& ProtoBsonData::_internal_var_bin() const {
  return _impl_.var_bin_.Get();
}
inline void ProtoBsonData::_internal_set_var_bin(const std::string& value) {
  
  _impl_.var_bin_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonData::_internal_mutable_var_bin() {
  
  return _impl_.var_bin_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonData::release_var_bin() {
  // @@protoc_insertion_point(field_release:S2S.ProtoBsonData.var_bin)
  return _impl_.var_bin_.Release();
}
inline void ProtoBsonData::set_allocated_var_bin(std::string* var_bin) {
  if (var_bin != nullptr) {
    
  } else {
    
  }
  _impl_.var_bin_.SetAllocated(var_bin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.var_bin_.IsDefault()) {
    _impl_.var_bin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.ProtoBsonData.var_bin)
}

// -------------------------------------------------------------------

// ProtoBsonObj

// repeated .S2S.ProtoBsonData bson_data_list = 1;
inline int ProtoBsonObj::_internal_bson_data_list_size() const {
  return _impl_.bson_data_list_.size();
}
inline int ProtoBsonObj::bson_data_list_size() const {
  return _internal_bson_data_list_size();
}
inline void ProtoBsonObj::clear_bson_data_list() {
  _impl_.bson_data_list_.Clear();
}
inline ::S2S::ProtoBsonData* ProtoBsonObj::mutable_bson_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:S2S.ProtoBsonObj.bson_data_list)
  return _impl_.bson_data_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonData >*
ProtoBsonObj::mutable_bson_data_list() {
  // @@protoc_insertion_point(field_mutable_list:S2S.ProtoBsonObj.bson_data_list)
  return &_impl_.bson_data_list_;
}
inline const ::S2S::ProtoBsonData& ProtoBsonObj::_internal_bson_data_list(int index) const {
  return _impl_.bson_data_list_.Get(index);
}
inline const ::S2S::ProtoBsonData& ProtoBsonObj::bson_data_list(int index) const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonObj.bson_data_list)
  return _internal_bson_data_list(index);
}
inline ::S2S::ProtoBsonData* ProtoBsonObj::_internal_add_bson_data_list() {
  return _impl_.bson_data_list_.Add();
}
inline ::S2S::ProtoBsonData* ProtoBsonObj::add_bson_data_list() {
  ::S2S::ProtoBsonData* _add = _internal_add_bson_data_list();
  // @@protoc_insertion_point(field_add:S2S.ProtoBsonObj.bson_data_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonData >&
ProtoBsonObj::bson_data_list() const {
  // @@protoc_insertion_point(field_list:S2S.ProtoBsonObj.bson_data_list)
  return _impl_.bson_data_list_;
}

// -------------------------------------------------------------------

// MongoUserData

// int32 cmd = 1;
inline void MongoUserData::clear_cmd() {
  _impl_.cmd_ = 0;
}
inline int32_t MongoUserData::_internal_cmd() const {
  return _impl_.cmd_;
}
inline int32_t MongoUserData::cmd() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.cmd)
  return _internal_cmd();
}
inline void MongoUserData::_internal_set_cmd(int32_t value) {
  
  _impl_.cmd_ = value;
}
inline void MongoUserData::set_cmd(int32_t value) {
  _internal_set_cmd(value);
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.cmd)
}

// int32 int32_var1 = 2;
inline void MongoUserData::clear_int32_var1() {
  _impl_.int32_var1_ = 0;
}
inline int32_t MongoUserData::_internal_int32_var1() const {
  return _impl_.int32_var1_;
}
inline int32_t MongoUserData::int32_var1() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.int32_var1)
  return _internal_int32_var1();
}
inline void MongoUserData::_internal_set_int32_var1(int32_t value) {
  
  _impl_.int32_var1_ = value;
}
inline void MongoUserData::set_int32_var1(int32_t value) {
  _internal_set_int32_var1(value);
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.int32_var1)
}

// int32 int32_var2 = 3;
inline void MongoUserData::clear_int32_var2() {
  _impl_.int32_var2_ = 0;
}
inline int32_t MongoUserData::_internal_int32_var2() const {
  return _impl_.int32_var2_;
}
inline int32_t MongoUserData::int32_var2() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.int32_var2)
  return _internal_int32_var2();
}
inline void MongoUserData::_internal_set_int32_var2(int32_t value) {
  
  _impl_.int32_var2_ = value;
}
inline void MongoUserData::set_int32_var2(int32_t value) {
  _internal_set_int32_var2(value);
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.int32_var2)
}

// int64 int64_var1 = 4;
inline void MongoUserData::clear_int64_var1() {
  _impl_.int64_var1_ = int64_t{0};
}
inline int64_t MongoUserData::_internal_int64_var1() const {
  return _impl_.int64_var1_;
}
inline int64_t MongoUserData::int64_var1() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.int64_var1)
  return _internal_int64_var1();
}
inline void MongoUserData::_internal_set_int64_var1(int64_t value) {
  
  _impl_.int64_var1_ = value;
}
inline void MongoUserData::set_int64_var1(int64_t value) {
  _internal_set_int64_var1(value);
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.int64_var1)
}

// int64 int64_var2 = 5;
inline void MongoUserData::clear_int64_var2() {
  _impl_.int64_var2_ = int64_t{0};
}
inline int64_t MongoUserData::_internal_int64_var2() const {
  return _impl_.int64_var2_;
}
inline int64_t MongoUserData::int64_var2() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.int64_var2)
  return _internal_int64_var2();
}
inline void MongoUserData::_internal_set_int64_var2(int64_t value) {
  
  _impl_.int64_var2_ = value;
}
inline void MongoUserData::set_int64_var2(int64_t value) {
  _internal_set_int64_var2(value);
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.int64_var2)
}

// string string_var1 = 6;
inline void MongoUserData::clear_string_var1() {
  _impl_.string_var1_.ClearToEmpty();
}
inline const std::string& MongoUserData::string_var1() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.string_var1)
  return _internal_string_var1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUserData::set_string_var1(ArgT0&& arg0, ArgT... args) {
 
 _impl_.string_var1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.string_var1)
}
inline std::string* MongoUserData::mutable_string_var1() {
  std::string* _s = _internal_mutable_string_var1();
  // @@protoc_insertion_point(field_mutable:S2S.MongoUserData.string_var1)
  return _s;
}
inline const std::string& MongoUserData::_internal_string_var1() const {
  return _impl_.string_var1_.Get();
}
inline void MongoUserData::_internal_set_string_var1(const std::string& value) {
  
  _impl_.string_var1_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUserData::_internal_mutable_string_var1() {
  
  return _impl_.string_var1_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUserData::release_string_var1() {
  // @@protoc_insertion_point(field_release:S2S.MongoUserData.string_var1)
  return _impl_.string_var1_.Release();
}
inline void MongoUserData::set_allocated_string_var1(std::string* string_var1) {
  if (string_var1 != nullptr) {
    
  } else {
    
  }
  _impl_.string_var1_.SetAllocated(string_var1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_var1_.IsDefault()) {
    _impl_.string_var1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoUserData.string_var1)
}

// string string_var2 = 7;
inline void MongoUserData::clear_string_var2() {
  _impl_.string_var2_.ClearToEmpty();
}
inline const std::string& MongoUserData::string_var2() const {
  // @@protoc_insertion_point(field_get:S2S.MongoUserData.string_var2)
  return _internal_string_var2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoUserData::set_string_var2(ArgT0&& arg0, ArgT... args) {
 
 _impl_.string_var2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoUserData.string_var2)
}
inline std::string* MongoUserData::mutable_string_var2() {
  std::string* _s = _internal_mutable_string_var2();
  // @@protoc_insertion_point(field_mutable:S2S.MongoUserData.string_var2)
  return _s;
}
inline const std::string& MongoUserData::_internal_string_var2() const {
  return _impl_.string_var2_.Get();
}
inline void MongoUserData::_internal_set_string_var2(const std::string& value) {
  
  _impl_.string_var2_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoUserData::_internal_mutable_string_var2() {
  
  return _impl_.string_var2_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoUserData::release_string_var2() {
  // @@protoc_insertion_point(field_release:S2S.MongoUserData.string_var2)
  return _impl_.string_var2_.Release();
}
inline void MongoUserData::set_allocated_string_var2(std::string* string_var2) {
  if (string_var2 != nullptr) {
    
  } else {
    
  }
  _impl_.string_var2_.SetAllocated(string_var2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.string_var2_.IsDefault()) {
    _impl_.string_var2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoUserData.string_var2)
}

// -------------------------------------------------------------------

// MongoInsertReq

// string db_name = 1;
inline void MongoInsertReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoInsertReq::db_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoInsertReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoInsertReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoInsertReq.db_name)
}
inline std::string* MongoInsertReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoInsertReq.db_name)
  return _s;
}
inline const std::string& MongoInsertReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoInsertReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoInsertReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoInsertReq::release_db_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoInsertReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoInsertReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoInsertReq.db_name)
}

// string col_name = 2;
inline void MongoInsertReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoInsertReq::col_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoInsertReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoInsertReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoInsertReq.col_name)
}
inline std::string* MongoInsertReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoInsertReq.col_name)
  return _s;
}
inline const std::string& MongoInsertReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoInsertReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoInsertReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoInsertReq::release_col_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoInsertReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoInsertReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoInsertReq.col_name)
}

// .S2S.ProtoBsonObj doc = 3;
inline bool MongoInsertReq::_internal_has_doc() const {
  return this != internal_default_instance() && _impl_.doc_ != nullptr;
}
inline bool MongoInsertReq::has_doc() const {
  return _internal_has_doc();
}
inline void MongoInsertReq::clear_doc() {
  if (GetArenaForAllocation() == nullptr && _impl_.doc_ != nullptr) {
    delete _impl_.doc_;
  }
  _impl_.doc_ = nullptr;
}
inline const ::S2S::ProtoBsonObj& MongoInsertReq::_internal_doc() const {
  const ::S2S::ProtoBsonObj* p = _impl_.doc_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonObj&>(
      ::S2S::_ProtoBsonObj_default_instance_);
}
inline const ::S2S::ProtoBsonObj& MongoInsertReq::doc() const {
  // @@protoc_insertion_point(field_get:S2S.MongoInsertReq.doc)
  return _internal_doc();
}
inline void MongoInsertReq::unsafe_arena_set_allocated_doc(
    ::S2S::ProtoBsonObj* doc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.doc_);
  }
  _impl_.doc_ = doc;
  if (doc) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoInsertReq.doc)
}
inline ::S2S::ProtoBsonObj* MongoInsertReq::release_doc() {
  
  ::S2S::ProtoBsonObj* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoInsertReq::unsafe_arena_release_doc() {
  // @@protoc_insertion_point(field_release:S2S.MongoInsertReq.doc)
  
  ::S2S::ProtoBsonObj* temp = _impl_.doc_;
  _impl_.doc_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoInsertReq::_internal_mutable_doc() {
  
  if (_impl_.doc_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.doc_ = p;
  }
  return _impl_.doc_;
}
inline ::S2S::ProtoBsonObj* MongoInsertReq::mutable_doc() {
  ::S2S::ProtoBsonObj* _msg = _internal_mutable_doc();
  // @@protoc_insertion_point(field_mutable:S2S.MongoInsertReq.doc)
  return _msg;
}
inline void MongoInsertReq::set_allocated_doc(::S2S::ProtoBsonObj* doc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.doc_;
  }
  if (doc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(doc);
    if (message_arena != submessage_arena) {
      doc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doc, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.doc_ = doc;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoInsertReq.doc)
}

// -------------------------------------------------------------------

// MongoInsertRes

// bool success = 1;
inline void MongoInsertRes::clear_success() {
  _impl_.success_ = false;
}
inline bool MongoInsertRes::_internal_success() const {
  return _impl_.success_;
}
inline bool MongoInsertRes::success() const {
  // @@protoc_insertion_point(field_get:S2S.MongoInsertRes.success)
  return _internal_success();
}
inline void MongoInsertRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MongoInsertRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:S2S.MongoInsertRes.success)
}

// .S2S.MongoUserData user_data = 2;
inline bool MongoInsertRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoInsertRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoInsertRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::S2S::MongoUserData& MongoInsertRes::_internal_user_data() const {
  const ::S2S::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoUserData&>(
      ::S2S::_MongoUserData_default_instance_);
}
inline const ::S2S::MongoUserData& MongoInsertRes::user_data() const {
  // @@protoc_insertion_point(field_get:S2S.MongoInsertRes.user_data)
  return _internal_user_data();
}
inline void MongoInsertRes::unsafe_arena_set_allocated_user_data(
    ::S2S::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoInsertRes.user_data)
}
inline ::S2S::MongoUserData* MongoInsertRes::release_user_data() {
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoUserData* MongoInsertRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:S2S.MongoInsertRes.user_data)
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::S2S::MongoUserData* MongoInsertRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::S2S::MongoUserData* MongoInsertRes::mutable_user_data() {
  ::S2S::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:S2S.MongoInsertRes.user_data)
  return _msg;
}
inline void MongoInsertRes::set_allocated_user_data(::S2S::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoInsertRes.user_data)
}

// -------------------------------------------------------------------

// MongoRemoveReq

// string db_name = 1;
inline void MongoRemoveReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoRemoveReq::db_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoRemoveReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoRemoveReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoRemoveReq.db_name)
}
inline std::string* MongoRemoveReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoRemoveReq.db_name)
  return _s;
}
inline const std::string& MongoRemoveReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoRemoveReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::release_db_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoRemoveReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoRemoveReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoRemoveReq.db_name)
}

// string col_name = 2;
inline void MongoRemoveReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoRemoveReq::col_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoRemoveReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoRemoveReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoRemoveReq.col_name)
}
inline std::string* MongoRemoveReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoRemoveReq.col_name)
  return _s;
}
inline const std::string& MongoRemoveReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoRemoveReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoRemoveReq::release_col_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoRemoveReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoRemoveReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoRemoveReq.col_name)
}

// .S2S.ProtoBsonObj selector = 3;
inline bool MongoRemoveReq::_internal_has_selector() const {
  return this != internal_default_instance() && _impl_.selector_ != nullptr;
}
inline bool MongoRemoveReq::has_selector() const {
  return _internal_has_selector();
}
inline void MongoRemoveReq::clear_selector() {
  if (GetArenaForAllocation() == nullptr && _impl_.selector_ != nullptr) {
    delete _impl_.selector_;
  }
  _impl_.selector_ = nullptr;
}
inline const ::S2S::ProtoBsonObj& MongoRemoveReq::_internal_selector() const {
  const ::S2S::ProtoBsonObj* p = _impl_.selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonObj&>(
      ::S2S::_ProtoBsonObj_default_instance_);
}
inline const ::S2S::ProtoBsonObj& MongoRemoveReq::selector() const {
  // @@protoc_insertion_point(field_get:S2S.MongoRemoveReq.selector)
  return _internal_selector();
}
inline void MongoRemoveReq::unsafe_arena_set_allocated_selector(
    ::S2S::ProtoBsonObj* selector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selector_);
  }
  _impl_.selector_ = selector;
  if (selector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoRemoveReq.selector)
}
inline ::S2S::ProtoBsonObj* MongoRemoveReq::release_selector() {
  
  ::S2S::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoRemoveReq::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_release:S2S.MongoRemoveReq.selector)
  
  ::S2S::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoRemoveReq::_internal_mutable_selector() {
  
  if (_impl_.selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.selector_ = p;
  }
  return _impl_.selector_;
}
inline ::S2S::ProtoBsonObj* MongoRemoveReq::mutable_selector() {
  ::S2S::ProtoBsonObj* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:S2S.MongoRemoveReq.selector)
  return _msg;
}
inline void MongoRemoveReq::set_allocated_selector(::S2S::ProtoBsonObj* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selector_;
  }
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.selector_ = selector;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoRemoveReq.selector)
}

// -------------------------------------------------------------------

// MongoRemoveRes

// bool success = 1;
inline void MongoRemoveRes::clear_success() {
  _impl_.success_ = false;
}
inline bool MongoRemoveRes::_internal_success() const {
  return _impl_.success_;
}
inline bool MongoRemoveRes::success() const {
  // @@protoc_insertion_point(field_get:S2S.MongoRemoveRes.success)
  return _internal_success();
}
inline void MongoRemoveRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MongoRemoveRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:S2S.MongoRemoveRes.success)
}

// .S2S.MongoUserData user_data = 2;
inline bool MongoRemoveRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoRemoveRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoRemoveRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::S2S::MongoUserData& MongoRemoveRes::_internal_user_data() const {
  const ::S2S::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoUserData&>(
      ::S2S::_MongoUserData_default_instance_);
}
inline const ::S2S::MongoUserData& MongoRemoveRes::user_data() const {
  // @@protoc_insertion_point(field_get:S2S.MongoRemoveRes.user_data)
  return _internal_user_data();
}
inline void MongoRemoveRes::unsafe_arena_set_allocated_user_data(
    ::S2S::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoRemoveRes.user_data)
}
inline ::S2S::MongoUserData* MongoRemoveRes::release_user_data() {
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoUserData* MongoRemoveRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:S2S.MongoRemoveRes.user_data)
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::S2S::MongoUserData* MongoRemoveRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::S2S::MongoUserData* MongoRemoveRes::mutable_user_data() {
  ::S2S::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:S2S.MongoRemoveRes.user_data)
  return _msg;
}
inline void MongoRemoveRes::set_allocated_user_data(::S2S::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoRemoveRes.user_data)
}

// -------------------------------------------------------------------

// MongoSaveReq

// string db_name = 1;
inline void MongoSaveReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoSaveReq::db_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoSaveReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoSaveReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoSaveReq.db_name)
}
inline std::string* MongoSaveReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoSaveReq.db_name)
  return _s;
}
inline const std::string& MongoSaveReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoSaveReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoSaveReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoSaveReq::release_db_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoSaveReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoSaveReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoSaveReq.db_name)
}

// string col_name = 2;
inline void MongoSaveReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoSaveReq::col_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoSaveReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoSaveReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoSaveReq.col_name)
}
inline std::string* MongoSaveReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoSaveReq.col_name)
  return _s;
}
inline const std::string& MongoSaveReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoSaveReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoSaveReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoSaveReq::release_col_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoSaveReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoSaveReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoSaveReq.col_name)
}

// .S2S.ProtoBsonObj selector = 3;
inline bool MongoSaveReq::_internal_has_selector() const {
  return this != internal_default_instance() && _impl_.selector_ != nullptr;
}
inline bool MongoSaveReq::has_selector() const {
  return _internal_has_selector();
}
inline void MongoSaveReq::clear_selector() {
  if (GetArenaForAllocation() == nullptr && _impl_.selector_ != nullptr) {
    delete _impl_.selector_;
  }
  _impl_.selector_ = nullptr;
}
inline const ::S2S::ProtoBsonObj& MongoSaveReq::_internal_selector() const {
  const ::S2S::ProtoBsonObj* p = _impl_.selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonObj&>(
      ::S2S::_ProtoBsonObj_default_instance_);
}
inline const ::S2S::ProtoBsonObj& MongoSaveReq::selector() const {
  // @@protoc_insertion_point(field_get:S2S.MongoSaveReq.selector)
  return _internal_selector();
}
inline void MongoSaveReq::unsafe_arena_set_allocated_selector(
    ::S2S::ProtoBsonObj* selector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selector_);
  }
  _impl_.selector_ = selector;
  if (selector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoSaveReq.selector)
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::release_selector() {
  
  ::S2S::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_release:S2S.MongoSaveReq.selector)
  
  ::S2S::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::_internal_mutable_selector() {
  
  if (_impl_.selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.selector_ = p;
  }
  return _impl_.selector_;
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::mutable_selector() {
  ::S2S::ProtoBsonObj* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:S2S.MongoSaveReq.selector)
  return _msg;
}
inline void MongoSaveReq::set_allocated_selector(::S2S::ProtoBsonObj* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selector_;
  }
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.selector_ = selector;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoSaveReq.selector)
}

// .S2S.ProtoBsonObj updator = 4;
inline bool MongoSaveReq::_internal_has_updator() const {
  return this != internal_default_instance() && _impl_.updator_ != nullptr;
}
inline bool MongoSaveReq::has_updator() const {
  return _internal_has_updator();
}
inline void MongoSaveReq::clear_updator() {
  if (GetArenaForAllocation() == nullptr && _impl_.updator_ != nullptr) {
    delete _impl_.updator_;
  }
  _impl_.updator_ = nullptr;
}
inline const ::S2S::ProtoBsonObj& MongoSaveReq::_internal_updator() const {
  const ::S2S::ProtoBsonObj* p = _impl_.updator_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonObj&>(
      ::S2S::_ProtoBsonObj_default_instance_);
}
inline const ::S2S::ProtoBsonObj& MongoSaveReq::updator() const {
  // @@protoc_insertion_point(field_get:S2S.MongoSaveReq.updator)
  return _internal_updator();
}
inline void MongoSaveReq::unsafe_arena_set_allocated_updator(
    ::S2S::ProtoBsonObj* updator) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.updator_);
  }
  _impl_.updator_ = updator;
  if (updator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoSaveReq.updator)
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::release_updator() {
  
  ::S2S::ProtoBsonObj* temp = _impl_.updator_;
  _impl_.updator_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::unsafe_arena_release_updator() {
  // @@protoc_insertion_point(field_release:S2S.MongoSaveReq.updator)
  
  ::S2S::ProtoBsonObj* temp = _impl_.updator_;
  _impl_.updator_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::_internal_mutable_updator() {
  
  if (_impl_.updator_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.updator_ = p;
  }
  return _impl_.updator_;
}
inline ::S2S::ProtoBsonObj* MongoSaveReq::mutable_updator() {
  ::S2S::ProtoBsonObj* _msg = _internal_mutable_updator();
  // @@protoc_insertion_point(field_mutable:S2S.MongoSaveReq.updator)
  return _msg;
}
inline void MongoSaveReq::set_allocated_updator(::S2S::ProtoBsonObj* updator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.updator_;
  }
  if (updator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(updator);
    if (message_arena != submessage_arena) {
      updator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, updator, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.updator_ = updator;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoSaveReq.updator)
}

// -------------------------------------------------------------------

// MongoSaveRes

// bool success = 1;
inline void MongoSaveRes::clear_success() {
  _impl_.success_ = false;
}
inline bool MongoSaveRes::_internal_success() const {
  return _impl_.success_;
}
inline bool MongoSaveRes::success() const {
  // @@protoc_insertion_point(field_get:S2S.MongoSaveRes.success)
  return _internal_success();
}
inline void MongoSaveRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MongoSaveRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:S2S.MongoSaveRes.success)
}

// .S2S.MongoUserData user_data = 2;
inline bool MongoSaveRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoSaveRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoSaveRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::S2S::MongoUserData& MongoSaveRes::_internal_user_data() const {
  const ::S2S::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoUserData&>(
      ::S2S::_MongoUserData_default_instance_);
}
inline const ::S2S::MongoUserData& MongoSaveRes::user_data() const {
  // @@protoc_insertion_point(field_get:S2S.MongoSaveRes.user_data)
  return _internal_user_data();
}
inline void MongoSaveRes::unsafe_arena_set_allocated_user_data(
    ::S2S::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoSaveRes.user_data)
}
inline ::S2S::MongoUserData* MongoSaveRes::release_user_data() {
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoUserData* MongoSaveRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:S2S.MongoSaveRes.user_data)
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::S2S::MongoUserData* MongoSaveRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::S2S::MongoUserData* MongoSaveRes::mutable_user_data() {
  ::S2S::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:S2S.MongoSaveRes.user_data)
  return _msg;
}
inline void MongoSaveRes::set_allocated_user_data(::S2S::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoSaveRes.user_data)
}

// -------------------------------------------------------------------

// MongoFindReq

// string db_name = 1;
inline void MongoFindReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoFindReq::db_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoFindReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoFindReq.db_name)
}
inline std::string* MongoFindReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoFindReq.db_name)
  return _s;
}
inline const std::string& MongoFindReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoFindReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoFindReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoFindReq::release_db_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoFindReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoFindReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoFindReq.db_name)
}

// string col_name = 2;
inline void MongoFindReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoFindReq::col_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoFindReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoFindReq.col_name)
}
inline std::string* MongoFindReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoFindReq.col_name)
  return _s;
}
inline const std::string& MongoFindReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoFindReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoFindReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoFindReq::release_col_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoFindReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoFindReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoFindReq.col_name)
}

// .S2S.ProtoBsonObj selector = 3;
inline bool MongoFindReq::_internal_has_selector() const {
  return this != internal_default_instance() && _impl_.selector_ != nullptr;
}
inline bool MongoFindReq::has_selector() const {
  return _internal_has_selector();
}
inline void MongoFindReq::clear_selector() {
  if (GetArenaForAllocation() == nullptr && _impl_.selector_ != nullptr) {
    delete _impl_.selector_;
  }
  _impl_.selector_ = nullptr;
}
inline const ::S2S::ProtoBsonObj& MongoFindReq::_internal_selector() const {
  const ::S2S::ProtoBsonObj* p = _impl_.selector_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonObj&>(
      ::S2S::_ProtoBsonObj_default_instance_);
}
inline const ::S2S::ProtoBsonObj& MongoFindReq::selector() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindReq.selector)
  return _internal_selector();
}
inline void MongoFindReq::unsafe_arena_set_allocated_selector(
    ::S2S::ProtoBsonObj* selector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.selector_);
  }
  _impl_.selector_ = selector;
  if (selector) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoFindReq.selector)
}
inline ::S2S::ProtoBsonObj* MongoFindReq::release_selector() {
  
  ::S2S::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoFindReq::unsafe_arena_release_selector() {
  // @@protoc_insertion_point(field_release:S2S.MongoFindReq.selector)
  
  ::S2S::ProtoBsonObj* temp = _impl_.selector_;
  _impl_.selector_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoFindReq::_internal_mutable_selector() {
  
  if (_impl_.selector_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.selector_ = p;
  }
  return _impl_.selector_;
}
inline ::S2S::ProtoBsonObj* MongoFindReq::mutable_selector() {
  ::S2S::ProtoBsonObj* _msg = _internal_mutable_selector();
  // @@protoc_insertion_point(field_mutable:S2S.MongoFindReq.selector)
  return _msg;
}
inline void MongoFindReq::set_allocated_selector(::S2S::ProtoBsonObj* selector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.selector_;
  }
  if (selector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(selector);
    if (message_arena != submessage_arena) {
      selector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, selector, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.selector_ = selector;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoFindReq.selector)
}

// int32 skip = 4;
inline void MongoFindReq::clear_skip() {
  _impl_.skip_ = 0;
}
inline int32_t MongoFindReq::_internal_skip() const {
  return _impl_.skip_;
}
inline int32_t MongoFindReq::skip() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindReq.skip)
  return _internal_skip();
}
inline void MongoFindReq::_internal_set_skip(int32_t value) {
  
  _impl_.skip_ = value;
}
inline void MongoFindReq::set_skip(int32_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:S2S.MongoFindReq.skip)
}

// int32 limit = 5;
inline void MongoFindReq::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t MongoFindReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t MongoFindReq::limit() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindReq.limit)
  return _internal_limit();
}
inline void MongoFindReq::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void MongoFindReq::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:S2S.MongoFindReq.limit)
}

// -------------------------------------------------------------------

// MongoFindRes

// bool success = 1;
inline void MongoFindRes::clear_success() {
  _impl_.success_ = false;
}
inline bool MongoFindRes::_internal_success() const {
  return _impl_.success_;
}
inline bool MongoFindRes::success() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindRes.success)
  return _internal_success();
}
inline void MongoFindRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MongoFindRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:S2S.MongoFindRes.success)
}

// repeated .S2S.ProtoBsonObj data_list = 2;
inline int MongoFindRes::_internal_data_list_size() const {
  return _impl_.data_list_.size();
}
inline int MongoFindRes::data_list_size() const {
  return _internal_data_list_size();
}
inline void MongoFindRes::clear_data_list() {
  _impl_.data_list_.Clear();
}
inline ::S2S::ProtoBsonObj* MongoFindRes::mutable_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:S2S.MongoFindRes.data_list)
  return _impl_.data_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >*
MongoFindRes::mutable_data_list() {
  // @@protoc_insertion_point(field_mutable_list:S2S.MongoFindRes.data_list)
  return &_impl_.data_list_;
}
inline const ::S2S::ProtoBsonObj& MongoFindRes::_internal_data_list(int index) const {
  return _impl_.data_list_.Get(index);
}
inline const ::S2S::ProtoBsonObj& MongoFindRes::data_list(int index) const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindRes.data_list)
  return _internal_data_list(index);
}
inline ::S2S::ProtoBsonObj* MongoFindRes::_internal_add_data_list() {
  return _impl_.data_list_.Add();
}
inline ::S2S::ProtoBsonObj* MongoFindRes::add_data_list() {
  ::S2S::ProtoBsonObj* _add = _internal_add_data_list();
  // @@protoc_insertion_point(field_add:S2S.MongoFindRes.data_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >&
MongoFindRes::data_list() const {
  // @@protoc_insertion_point(field_list:S2S.MongoFindRes.data_list)
  return _impl_.data_list_;
}

// .S2S.MongoUserData user_data = 3;
inline bool MongoFindRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoFindRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoFindRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::S2S::MongoUserData& MongoFindRes::_internal_user_data() const {
  const ::S2S::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoUserData&>(
      ::S2S::_MongoUserData_default_instance_);
}
inline const ::S2S::MongoUserData& MongoFindRes::user_data() const {
  // @@protoc_insertion_point(field_get:S2S.MongoFindRes.user_data)
  return _internal_user_data();
}
inline void MongoFindRes::unsafe_arena_set_allocated_user_data(
    ::S2S::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoFindRes.user_data)
}
inline ::S2S::MongoUserData* MongoFindRes::release_user_data() {
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoUserData* MongoFindRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:S2S.MongoFindRes.user_data)
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::S2S::MongoUserData* MongoFindRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::S2S::MongoUserData* MongoFindRes::mutable_user_data() {
  ::S2S::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:S2S.MongoFindRes.user_data)
  return _msg;
}
inline void MongoFindRes::set_allocated_user_data(::S2S::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoFindRes.user_data)
}

// -------------------------------------------------------------------

// ProtoBsonBatchFindData

// string key = 1;
inline void ProtoBsonBatchFindData::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& ProtoBsonBatchFindData::key() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonBatchFindData.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtoBsonBatchFindData::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonBatchFindData.key)
}
inline std::string* ProtoBsonBatchFindData::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:S2S.ProtoBsonBatchFindData.key)
  return _s;
}
inline const std::string& ProtoBsonBatchFindData::_internal_key() const {
  return _impl_.key_.Get();
}
inline void ProtoBsonBatchFindData::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* ProtoBsonBatchFindData::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* ProtoBsonBatchFindData::release_key() {
  // @@protoc_insertion_point(field_release:S2S.ProtoBsonBatchFindData.key)
  return _impl_.key_.Release();
}
inline void ProtoBsonBatchFindData::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.ProtoBsonBatchFindData.key)
}

// int32 data_type = 2;
inline void ProtoBsonBatchFindData::clear_data_type() {
  _impl_.data_type_ = 0;
}
inline int32_t ProtoBsonBatchFindData::_internal_data_type() const {
  return _impl_.data_type_;
}
inline int32_t ProtoBsonBatchFindData::data_type() const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonBatchFindData.data_type)
  return _internal_data_type();
}
inline void ProtoBsonBatchFindData::_internal_set_data_type(int32_t value) {
  
  _impl_.data_type_ = value;
}
inline void ProtoBsonBatchFindData::set_data_type(int32_t value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonBatchFindData.data_type)
}

// repeated int32 int32_var_list = 3;
inline int ProtoBsonBatchFindData::_internal_int32_var_list_size() const {
  return _impl_.int32_var_list_.size();
}
inline int ProtoBsonBatchFindData::int32_var_list_size() const {
  return _internal_int32_var_list_size();
}
inline void ProtoBsonBatchFindData::clear_int32_var_list() {
  _impl_.int32_var_list_.Clear();
}
inline int32_t ProtoBsonBatchFindData::_internal_int32_var_list(int index) const {
  return _impl_.int32_var_list_.Get(index);
}
inline int32_t ProtoBsonBatchFindData::int32_var_list(int index) const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonBatchFindData.int32_var_list)
  return _internal_int32_var_list(index);
}
inline void ProtoBsonBatchFindData::set_int32_var_list(int index, int32_t value) {
  _impl_.int32_var_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonBatchFindData.int32_var_list)
}
inline void ProtoBsonBatchFindData::_internal_add_int32_var_list(int32_t value) {
  _impl_.int32_var_list_.Add(value);
}
inline void ProtoBsonBatchFindData::add_int32_var_list(int32_t value) {
  _internal_add_int32_var_list(value);
  // @@protoc_insertion_point(field_add:S2S.ProtoBsonBatchFindData.int32_var_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ProtoBsonBatchFindData::_internal_int32_var_list() const {
  return _impl_.int32_var_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ProtoBsonBatchFindData::int32_var_list() const {
  // @@protoc_insertion_point(field_list:S2S.ProtoBsonBatchFindData.int32_var_list)
  return _internal_int32_var_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ProtoBsonBatchFindData::_internal_mutable_int32_var_list() {
  return &_impl_.int32_var_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ProtoBsonBatchFindData::mutable_int32_var_list() {
  // @@protoc_insertion_point(field_mutable_list:S2S.ProtoBsonBatchFindData.int32_var_list)
  return _internal_mutable_int32_var_list();
}

// repeated int64 int64_var_list = 4;
inline int ProtoBsonBatchFindData::_internal_int64_var_list_size() const {
  return _impl_.int64_var_list_.size();
}
inline int ProtoBsonBatchFindData::int64_var_list_size() const {
  return _internal_int64_var_list_size();
}
inline void ProtoBsonBatchFindData::clear_int64_var_list() {
  _impl_.int64_var_list_.Clear();
}
inline int64_t ProtoBsonBatchFindData::_internal_int64_var_list(int index) const {
  return _impl_.int64_var_list_.Get(index);
}
inline int64_t ProtoBsonBatchFindData::int64_var_list(int index) const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonBatchFindData.int64_var_list)
  return _internal_int64_var_list(index);
}
inline void ProtoBsonBatchFindData::set_int64_var_list(int index, int64_t value) {
  _impl_.int64_var_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonBatchFindData.int64_var_list)
}
inline void ProtoBsonBatchFindData::_internal_add_int64_var_list(int64_t value) {
  _impl_.int64_var_list_.Add(value);
}
inline void ProtoBsonBatchFindData::add_int64_var_list(int64_t value) {
  _internal_add_int64_var_list(value);
  // @@protoc_insertion_point(field_add:S2S.ProtoBsonBatchFindData.int64_var_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ProtoBsonBatchFindData::_internal_int64_var_list() const {
  return _impl_.int64_var_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ProtoBsonBatchFindData::int64_var_list() const {
  // @@protoc_insertion_point(field_list:S2S.ProtoBsonBatchFindData.int64_var_list)
  return _internal_int64_var_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ProtoBsonBatchFindData::_internal_mutable_int64_var_list() {
  return &_impl_.int64_var_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ProtoBsonBatchFindData::mutable_int64_var_list() {
  // @@protoc_insertion_point(field_mutable_list:S2S.ProtoBsonBatchFindData.int64_var_list)
  return _internal_mutable_int64_var_list();
}

// repeated string string_var_list = 5;
inline int ProtoBsonBatchFindData::_internal_string_var_list_size() const {
  return _impl_.string_var_list_.size();
}
inline int ProtoBsonBatchFindData::string_var_list_size() const {
  return _internal_string_var_list_size();
}
inline void ProtoBsonBatchFindData::clear_string_var_list() {
  _impl_.string_var_list_.Clear();
}
inline std::string* ProtoBsonBatchFindData::add_string_var_list() {
  std::string* _s = _internal_add_string_var_list();
  // @@protoc_insertion_point(field_add_mutable:S2S.ProtoBsonBatchFindData.string_var_list)
  return _s;
}
inline const std::string& ProtoBsonBatchFindData::_internal_string_var_list(int index) const {
  return _impl_.string_var_list_.Get(index);
}
inline const std::string& ProtoBsonBatchFindData::string_var_list(int index) const {
  // @@protoc_insertion_point(field_get:S2S.ProtoBsonBatchFindData.string_var_list)
  return _internal_string_var_list(index);
}
inline std::string* ProtoBsonBatchFindData::mutable_string_var_list(int index) {
  // @@protoc_insertion_point(field_mutable:S2S.ProtoBsonBatchFindData.string_var_list)
  return _impl_.string_var_list_.Mutable(index);
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, const std::string& value) {
  _impl_.string_var_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, std::string&& value) {
  _impl_.string_var_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.string_var_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::set_string_var_list(int index, const char* value, size_t size) {
  _impl_.string_var_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline std::string* ProtoBsonBatchFindData::_internal_add_string_var_list() {
  return _impl_.string_var_list_.Add();
}
inline void ProtoBsonBatchFindData::add_string_var_list(const std::string& value) {
  _impl_.string_var_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::add_string_var_list(std::string&& value) {
  _impl_.string_var_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::add_string_var_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.string_var_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline void ProtoBsonBatchFindData::add_string_var_list(const char* value, size_t size) {
  _impl_.string_var_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:S2S.ProtoBsonBatchFindData.string_var_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ProtoBsonBatchFindData::string_var_list() const {
  // @@protoc_insertion_point(field_list:S2S.ProtoBsonBatchFindData.string_var_list)
  return _impl_.string_var_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ProtoBsonBatchFindData::mutable_string_var_list() {
  // @@protoc_insertion_point(field_mutable_list:S2S.ProtoBsonBatchFindData.string_var_list)
  return &_impl_.string_var_list_;
}

// -------------------------------------------------------------------

// MongoBatchFindReq

// string db_name = 1;
inline void MongoBatchFindReq::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& MongoBatchFindReq::db_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoBatchFindReq::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindReq.db_name)
}
inline std::string* MongoBatchFindReq::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoBatchFindReq.db_name)
  return _s;
}
inline const std::string& MongoBatchFindReq::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void MongoBatchFindReq::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::release_db_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoBatchFindReq.db_name)
  return _impl_.db_name_.Release();
}
inline void MongoBatchFindReq::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoBatchFindReq.db_name)
}

// string col_name = 2;
inline void MongoBatchFindReq::clear_col_name() {
  _impl_.col_name_.ClearToEmpty();
}
inline const std::string& MongoBatchFindReq::col_name() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.col_name)
  return _internal_col_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MongoBatchFindReq::set_col_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindReq.col_name)
}
inline std::string* MongoBatchFindReq::mutable_col_name() {
  std::string* _s = _internal_mutable_col_name();
  // @@protoc_insertion_point(field_mutable:S2S.MongoBatchFindReq.col_name)
  return _s;
}
inline const std::string& MongoBatchFindReq::_internal_col_name() const {
  return _impl_.col_name_.Get();
}
inline void MongoBatchFindReq::_internal_set_col_name(const std::string& value) {
  
  _impl_.col_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::_internal_mutable_col_name() {
  
  return _impl_.col_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MongoBatchFindReq::release_col_name() {
  // @@protoc_insertion_point(field_release:S2S.MongoBatchFindReq.col_name)
  return _impl_.col_name_.Release();
}
inline void MongoBatchFindReq::set_allocated_col_name(std::string* col_name) {
  if (col_name != nullptr) {
    
  } else {
    
  }
  _impl_.col_name_.SetAllocated(col_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_name_.IsDefault()) {
    _impl_.col_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoBatchFindReq.col_name)
}

// .S2S.ProtoBsonBatchFindData query = 3;
inline bool MongoBatchFindReq::_internal_has_query() const {
  return this != internal_default_instance() && _impl_.query_ != nullptr;
}
inline bool MongoBatchFindReq::has_query() const {
  return _internal_has_query();
}
inline void MongoBatchFindReq::clear_query() {
  if (GetArenaForAllocation() == nullptr && _impl_.query_ != nullptr) {
    delete _impl_.query_;
  }
  _impl_.query_ = nullptr;
}
inline const ::S2S::ProtoBsonBatchFindData& MongoBatchFindReq::_internal_query() const {
  const ::S2S::ProtoBsonBatchFindData* p = _impl_.query_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonBatchFindData&>(
      ::S2S::_ProtoBsonBatchFindData_default_instance_);
}
inline const ::S2S::ProtoBsonBatchFindData& MongoBatchFindReq::query() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.query)
  return _internal_query();
}
inline void MongoBatchFindReq::unsafe_arena_set_allocated_query(
    ::S2S::ProtoBsonBatchFindData* query) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_);
  }
  _impl_.query_ = query;
  if (query) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoBatchFindReq.query)
}
inline ::S2S::ProtoBsonBatchFindData* MongoBatchFindReq::release_query() {
  
  ::S2S::ProtoBsonBatchFindData* temp = _impl_.query_;
  _impl_.query_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonBatchFindData* MongoBatchFindReq::unsafe_arena_release_query() {
  // @@protoc_insertion_point(field_release:S2S.MongoBatchFindReq.query)
  
  ::S2S::ProtoBsonBatchFindData* temp = _impl_.query_;
  _impl_.query_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonBatchFindData* MongoBatchFindReq::_internal_mutable_query() {
  
  if (_impl_.query_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonBatchFindData>(GetArenaForAllocation());
    _impl_.query_ = p;
  }
  return _impl_.query_;
}
inline ::S2S::ProtoBsonBatchFindData* MongoBatchFindReq::mutable_query() {
  ::S2S::ProtoBsonBatchFindData* _msg = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:S2S.MongoBatchFindReq.query)
  return _msg;
}
inline void MongoBatchFindReq::set_allocated_query(::S2S::ProtoBsonBatchFindData* query) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_;
  }
  if (query) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query);
    if (message_arena != submessage_arena) {
      query = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.query_ = query;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoBatchFindReq.query)
}

// .S2S.ProtoBsonObj fields = 4;
inline bool MongoBatchFindReq::_internal_has_fields() const {
  return this != internal_default_instance() && _impl_.fields_ != nullptr;
}
inline bool MongoBatchFindReq::has_fields() const {
  return _internal_has_fields();
}
inline void MongoBatchFindReq::clear_fields() {
  if (GetArenaForAllocation() == nullptr && _impl_.fields_ != nullptr) {
    delete _impl_.fields_;
  }
  _impl_.fields_ = nullptr;
}
inline const ::S2S::ProtoBsonObj& MongoBatchFindReq::_internal_fields() const {
  const ::S2S::ProtoBsonObj* p = _impl_.fields_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::ProtoBsonObj&>(
      ::S2S::_ProtoBsonObj_default_instance_);
}
inline const ::S2S::ProtoBsonObj& MongoBatchFindReq::fields() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.fields)
  return _internal_fields();
}
inline void MongoBatchFindReq::unsafe_arena_set_allocated_fields(
    ::S2S::ProtoBsonObj* fields) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fields_);
  }
  _impl_.fields_ = fields;
  if (fields) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoBatchFindReq.fields)
}
inline ::S2S::ProtoBsonObj* MongoBatchFindReq::release_fields() {
  
  ::S2S::ProtoBsonObj* temp = _impl_.fields_;
  _impl_.fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoBatchFindReq::unsafe_arena_release_fields() {
  // @@protoc_insertion_point(field_release:S2S.MongoBatchFindReq.fields)
  
  ::S2S::ProtoBsonObj* temp = _impl_.fields_;
  _impl_.fields_ = nullptr;
  return temp;
}
inline ::S2S::ProtoBsonObj* MongoBatchFindReq::_internal_mutable_fields() {
  
  if (_impl_.fields_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::ProtoBsonObj>(GetArenaForAllocation());
    _impl_.fields_ = p;
  }
  return _impl_.fields_;
}
inline ::S2S::ProtoBsonObj* MongoBatchFindReq::mutable_fields() {
  ::S2S::ProtoBsonObj* _msg = _internal_mutable_fields();
  // @@protoc_insertion_point(field_mutable:S2S.MongoBatchFindReq.fields)
  return _msg;
}
inline void MongoBatchFindReq::set_allocated_fields(::S2S::ProtoBsonObj* fields) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fields_;
  }
  if (fields) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fields);
    if (message_arena != submessage_arena) {
      fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fields, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fields_ = fields;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoBatchFindReq.fields)
}

// int32 logic_batch_num = 5;
inline void MongoBatchFindReq::clear_logic_batch_num() {
  _impl_.logic_batch_num_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_logic_batch_num() const {
  return _impl_.logic_batch_num_;
}
inline int32_t MongoBatchFindReq::logic_batch_num() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.logic_batch_num)
  return _internal_logic_batch_num();
}
inline void MongoBatchFindReq::_internal_set_logic_batch_num(int32_t value) {
  
  _impl_.logic_batch_num_ = value;
}
inline void MongoBatchFindReq::set_logic_batch_num(int32_t value) {
  _internal_set_logic_batch_num(value);
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindReq.logic_batch_num)
}

// int32 skip = 6;
inline void MongoBatchFindReq::clear_skip() {
  _impl_.skip_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_skip() const {
  return _impl_.skip_;
}
inline int32_t MongoBatchFindReq::skip() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.skip)
  return _internal_skip();
}
inline void MongoBatchFindReq::_internal_set_skip(int32_t value) {
  
  _impl_.skip_ = value;
}
inline void MongoBatchFindReq::set_skip(int32_t value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindReq.skip)
}

// int32 limit = 7;
inline void MongoBatchFindReq::clear_limit() {
  _impl_.limit_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_limit() const {
  return _impl_.limit_;
}
inline int32_t MongoBatchFindReq::limit() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.limit)
  return _internal_limit();
}
inline void MongoBatchFindReq::_internal_set_limit(int32_t value) {
  
  _impl_.limit_ = value;
}
inline void MongoBatchFindReq::set_limit(int32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindReq.limit)
}

// int32 batch_size = 8;
inline void MongoBatchFindReq::clear_batch_size() {
  _impl_.batch_size_ = 0;
}
inline int32_t MongoBatchFindReq::_internal_batch_size() const {
  return _impl_.batch_size_;
}
inline int32_t MongoBatchFindReq::batch_size() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindReq.batch_size)
  return _internal_batch_size();
}
inline void MongoBatchFindReq::_internal_set_batch_size(int32_t value) {
  
  _impl_.batch_size_ = value;
}
inline void MongoBatchFindReq::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindReq.batch_size)
}

// -------------------------------------------------------------------

// MongoBatchFindRes

// bool success = 1;
inline void MongoBatchFindRes::clear_success() {
  _impl_.success_ = false;
}
inline bool MongoBatchFindRes::_internal_success() const {
  return _impl_.success_;
}
inline bool MongoBatchFindRes::success() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindRes.success)
  return _internal_success();
}
inline void MongoBatchFindRes::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MongoBatchFindRes::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindRes.success)
}

// bool has_more = 2;
inline void MongoBatchFindRes::clear_has_more() {
  _impl_.has_more_ = false;
}
inline bool MongoBatchFindRes::_internal_has_more() const {
  return _impl_.has_more_;
}
inline bool MongoBatchFindRes::has_more() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindRes.has_more)
  return _internal_has_more();
}
inline void MongoBatchFindRes::_internal_set_has_more(bool value) {
  
  _impl_.has_more_ = value;
}
inline void MongoBatchFindRes::set_has_more(bool value) {
  _internal_set_has_more(value);
  // @@protoc_insertion_point(field_set:S2S.MongoBatchFindRes.has_more)
}

// repeated .S2S.ProtoBsonObj data_list = 3;
inline int MongoBatchFindRes::_internal_data_list_size() const {
  return _impl_.data_list_.size();
}
inline int MongoBatchFindRes::data_list_size() const {
  return _internal_data_list_size();
}
inline void MongoBatchFindRes::clear_data_list() {
  _impl_.data_list_.Clear();
}
inline ::S2S::ProtoBsonObj* MongoBatchFindRes::mutable_data_list(int index) {
  // @@protoc_insertion_point(field_mutable:S2S.MongoBatchFindRes.data_list)
  return _impl_.data_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >*
MongoBatchFindRes::mutable_data_list() {
  // @@protoc_insertion_point(field_mutable_list:S2S.MongoBatchFindRes.data_list)
  return &_impl_.data_list_;
}
inline const ::S2S::ProtoBsonObj& MongoBatchFindRes::_internal_data_list(int index) const {
  return _impl_.data_list_.Get(index);
}
inline const ::S2S::ProtoBsonObj& MongoBatchFindRes::data_list(int index) const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindRes.data_list)
  return _internal_data_list(index);
}
inline ::S2S::ProtoBsonObj* MongoBatchFindRes::_internal_add_data_list() {
  return _impl_.data_list_.Add();
}
inline ::S2S::ProtoBsonObj* MongoBatchFindRes::add_data_list() {
  ::S2S::ProtoBsonObj* _add = _internal_add_data_list();
  // @@protoc_insertion_point(field_add:S2S.MongoBatchFindRes.data_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::S2S::ProtoBsonObj >&
MongoBatchFindRes::data_list() const {
  // @@protoc_insertion_point(field_list:S2S.MongoBatchFindRes.data_list)
  return _impl_.data_list_;
}

// .S2S.MongoUserData user_data = 4;
inline bool MongoBatchFindRes::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoBatchFindRes::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoBatchFindRes::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::S2S::MongoUserData& MongoBatchFindRes::_internal_user_data() const {
  const ::S2S::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoUserData&>(
      ::S2S::_MongoUserData_default_instance_);
}
inline const ::S2S::MongoUserData& MongoBatchFindRes::user_data() const {
  // @@protoc_insertion_point(field_get:S2S.MongoBatchFindRes.user_data)
  return _internal_user_data();
}
inline void MongoBatchFindRes::unsafe_arena_set_allocated_user_data(
    ::S2S::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoBatchFindRes.user_data)
}
inline ::S2S::MongoUserData* MongoBatchFindRes::release_user_data() {
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoUserData* MongoBatchFindRes::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:S2S.MongoBatchFindRes.user_data)
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::S2S::MongoUserData* MongoBatchFindRes::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::S2S::MongoUserData* MongoBatchFindRes::mutable_user_data() {
  ::S2S::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:S2S.MongoBatchFindRes.user_data)
  return _msg;
}
inline void MongoBatchFindRes::set_allocated_user_data(::S2S::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoBatchFindRes.user_data)
}

// -------------------------------------------------------------------

// MongoDBMsg

// .S2S.MongoUserData user_data = 1;
inline bool MongoDBMsg::_internal_has_user_data() const {
  return this != internal_default_instance() && _impl_.user_data_ != nullptr;
}
inline bool MongoDBMsg::has_user_data() const {
  return _internal_has_user_data();
}
inline void MongoDBMsg::clear_user_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_data_ != nullptr) {
    delete _impl_.user_data_;
  }
  _impl_.user_data_ = nullptr;
}
inline const ::S2S::MongoUserData& MongoDBMsg::_internal_user_data() const {
  const ::S2S::MongoUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoUserData&>(
      ::S2S::_MongoUserData_default_instance_);
}
inline const ::S2S::MongoUserData& MongoDBMsg::user_data() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.user_data)
  return _internal_user_data();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_user_data(
    ::S2S::MongoUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.user_data)
}
inline ::S2S::MongoUserData* MongoDBMsg::release_user_data() {
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoUserData* MongoDBMsg::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.user_data)
  
  ::S2S::MongoUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::S2S::MongoUserData* MongoDBMsg::_internal_mutable_user_data() {
  
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::S2S::MongoUserData* MongoDBMsg::mutable_user_data() {
  ::S2S::MongoUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.user_data)
  return _msg;
}
inline void MongoDBMsg::set_allocated_user_data(::S2S::MongoUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.user_data)
}

// .S2S.MongoInsertReq insert_req = 2;
inline bool MongoDBMsg::_internal_has_insert_req() const {
  return this != internal_default_instance() && _impl_.insert_req_ != nullptr;
}
inline bool MongoDBMsg::has_insert_req() const {
  return _internal_has_insert_req();
}
inline void MongoDBMsg::clear_insert_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.insert_req_ != nullptr) {
    delete _impl_.insert_req_;
  }
  _impl_.insert_req_ = nullptr;
}
inline const ::S2S::MongoInsertReq& MongoDBMsg::_internal_insert_req() const {
  const ::S2S::MongoInsertReq* p = _impl_.insert_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoInsertReq&>(
      ::S2S::_MongoInsertReq_default_instance_);
}
inline const ::S2S::MongoInsertReq& MongoDBMsg::insert_req() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.insert_req)
  return _internal_insert_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_insert_req(
    ::S2S::MongoInsertReq* insert_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.insert_req_);
  }
  _impl_.insert_req_ = insert_req;
  if (insert_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.insert_req)
}
inline ::S2S::MongoInsertReq* MongoDBMsg::release_insert_req() {
  
  ::S2S::MongoInsertReq* temp = _impl_.insert_req_;
  _impl_.insert_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoInsertReq* MongoDBMsg::unsafe_arena_release_insert_req() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.insert_req)
  
  ::S2S::MongoInsertReq* temp = _impl_.insert_req_;
  _impl_.insert_req_ = nullptr;
  return temp;
}
inline ::S2S::MongoInsertReq* MongoDBMsg::_internal_mutable_insert_req() {
  
  if (_impl_.insert_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoInsertReq>(GetArenaForAllocation());
    _impl_.insert_req_ = p;
  }
  return _impl_.insert_req_;
}
inline ::S2S::MongoInsertReq* MongoDBMsg::mutable_insert_req() {
  ::S2S::MongoInsertReq* _msg = _internal_mutable_insert_req();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.insert_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_insert_req(::S2S::MongoInsertReq* insert_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.insert_req_;
  }
  if (insert_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(insert_req);
    if (message_arena != submessage_arena) {
      insert_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.insert_req_ = insert_req;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.insert_req)
}

// .S2S.MongoInsertRes insert_res = 3;
inline bool MongoDBMsg::_internal_has_insert_res() const {
  return this != internal_default_instance() && _impl_.insert_res_ != nullptr;
}
inline bool MongoDBMsg::has_insert_res() const {
  return _internal_has_insert_res();
}
inline void MongoDBMsg::clear_insert_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.insert_res_ != nullptr) {
    delete _impl_.insert_res_;
  }
  _impl_.insert_res_ = nullptr;
}
inline const ::S2S::MongoInsertRes& MongoDBMsg::_internal_insert_res() const {
  const ::S2S::MongoInsertRes* p = _impl_.insert_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoInsertRes&>(
      ::S2S::_MongoInsertRes_default_instance_);
}
inline const ::S2S::MongoInsertRes& MongoDBMsg::insert_res() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.insert_res)
  return _internal_insert_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_insert_res(
    ::S2S::MongoInsertRes* insert_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.insert_res_);
  }
  _impl_.insert_res_ = insert_res;
  if (insert_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.insert_res)
}
inline ::S2S::MongoInsertRes* MongoDBMsg::release_insert_res() {
  
  ::S2S::MongoInsertRes* temp = _impl_.insert_res_;
  _impl_.insert_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoInsertRes* MongoDBMsg::unsafe_arena_release_insert_res() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.insert_res)
  
  ::S2S::MongoInsertRes* temp = _impl_.insert_res_;
  _impl_.insert_res_ = nullptr;
  return temp;
}
inline ::S2S::MongoInsertRes* MongoDBMsg::_internal_mutable_insert_res() {
  
  if (_impl_.insert_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoInsertRes>(GetArenaForAllocation());
    _impl_.insert_res_ = p;
  }
  return _impl_.insert_res_;
}
inline ::S2S::MongoInsertRes* MongoDBMsg::mutable_insert_res() {
  ::S2S::MongoInsertRes* _msg = _internal_mutable_insert_res();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.insert_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_insert_res(::S2S::MongoInsertRes* insert_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.insert_res_;
  }
  if (insert_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(insert_res);
    if (message_arena != submessage_arena) {
      insert_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, insert_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.insert_res_ = insert_res;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.insert_res)
}

// .S2S.MongoRemoveReq remove_req = 4;
inline bool MongoDBMsg::_internal_has_remove_req() const {
  return this != internal_default_instance() && _impl_.remove_req_ != nullptr;
}
inline bool MongoDBMsg::has_remove_req() const {
  return _internal_has_remove_req();
}
inline void MongoDBMsg::clear_remove_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.remove_req_ != nullptr) {
    delete _impl_.remove_req_;
  }
  _impl_.remove_req_ = nullptr;
}
inline const ::S2S::MongoRemoveReq& MongoDBMsg::_internal_remove_req() const {
  const ::S2S::MongoRemoveReq* p = _impl_.remove_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoRemoveReq&>(
      ::S2S::_MongoRemoveReq_default_instance_);
}
inline const ::S2S::MongoRemoveReq& MongoDBMsg::remove_req() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.remove_req)
  return _internal_remove_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_remove_req(
    ::S2S::MongoRemoveReq* remove_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remove_req_);
  }
  _impl_.remove_req_ = remove_req;
  if (remove_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.remove_req)
}
inline ::S2S::MongoRemoveReq* MongoDBMsg::release_remove_req() {
  
  ::S2S::MongoRemoveReq* temp = _impl_.remove_req_;
  _impl_.remove_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoRemoveReq* MongoDBMsg::unsafe_arena_release_remove_req() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.remove_req)
  
  ::S2S::MongoRemoveReq* temp = _impl_.remove_req_;
  _impl_.remove_req_ = nullptr;
  return temp;
}
inline ::S2S::MongoRemoveReq* MongoDBMsg::_internal_mutable_remove_req() {
  
  if (_impl_.remove_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoRemoveReq>(GetArenaForAllocation());
    _impl_.remove_req_ = p;
  }
  return _impl_.remove_req_;
}
inline ::S2S::MongoRemoveReq* MongoDBMsg::mutable_remove_req() {
  ::S2S::MongoRemoveReq* _msg = _internal_mutable_remove_req();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.remove_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_remove_req(::S2S::MongoRemoveReq* remove_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remove_req_;
  }
  if (remove_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remove_req);
    if (message_arena != submessage_arena) {
      remove_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remove_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remove_req_ = remove_req;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.remove_req)
}

// .S2S.MongoRemoveRes remove_res = 5;
inline bool MongoDBMsg::_internal_has_remove_res() const {
  return this != internal_default_instance() && _impl_.remove_res_ != nullptr;
}
inline bool MongoDBMsg::has_remove_res() const {
  return _internal_has_remove_res();
}
inline void MongoDBMsg::clear_remove_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.remove_res_ != nullptr) {
    delete _impl_.remove_res_;
  }
  _impl_.remove_res_ = nullptr;
}
inline const ::S2S::MongoRemoveRes& MongoDBMsg::_internal_remove_res() const {
  const ::S2S::MongoRemoveRes* p = _impl_.remove_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoRemoveRes&>(
      ::S2S::_MongoRemoveRes_default_instance_);
}
inline const ::S2S::MongoRemoveRes& MongoDBMsg::remove_res() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.remove_res)
  return _internal_remove_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_remove_res(
    ::S2S::MongoRemoveRes* remove_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.remove_res_);
  }
  _impl_.remove_res_ = remove_res;
  if (remove_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.remove_res)
}
inline ::S2S::MongoRemoveRes* MongoDBMsg::release_remove_res() {
  
  ::S2S::MongoRemoveRes* temp = _impl_.remove_res_;
  _impl_.remove_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoRemoveRes* MongoDBMsg::unsafe_arena_release_remove_res() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.remove_res)
  
  ::S2S::MongoRemoveRes* temp = _impl_.remove_res_;
  _impl_.remove_res_ = nullptr;
  return temp;
}
inline ::S2S::MongoRemoveRes* MongoDBMsg::_internal_mutable_remove_res() {
  
  if (_impl_.remove_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoRemoveRes>(GetArenaForAllocation());
    _impl_.remove_res_ = p;
  }
  return _impl_.remove_res_;
}
inline ::S2S::MongoRemoveRes* MongoDBMsg::mutable_remove_res() {
  ::S2S::MongoRemoveRes* _msg = _internal_mutable_remove_res();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.remove_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_remove_res(::S2S::MongoRemoveRes* remove_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.remove_res_;
  }
  if (remove_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(remove_res);
    if (message_arena != submessage_arena) {
      remove_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, remove_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.remove_res_ = remove_res;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.remove_res)
}

// .S2S.MongoSaveReq save_req = 6;
inline bool MongoDBMsg::_internal_has_save_req() const {
  return this != internal_default_instance() && _impl_.save_req_ != nullptr;
}
inline bool MongoDBMsg::has_save_req() const {
  return _internal_has_save_req();
}
inline void MongoDBMsg::clear_save_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.save_req_ != nullptr) {
    delete _impl_.save_req_;
  }
  _impl_.save_req_ = nullptr;
}
inline const ::S2S::MongoSaveReq& MongoDBMsg::_internal_save_req() const {
  const ::S2S::MongoSaveReq* p = _impl_.save_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoSaveReq&>(
      ::S2S::_MongoSaveReq_default_instance_);
}
inline const ::S2S::MongoSaveReq& MongoDBMsg::save_req() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.save_req)
  return _internal_save_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_save_req(
    ::S2S::MongoSaveReq* save_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_req_);
  }
  _impl_.save_req_ = save_req;
  if (save_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.save_req)
}
inline ::S2S::MongoSaveReq* MongoDBMsg::release_save_req() {
  
  ::S2S::MongoSaveReq* temp = _impl_.save_req_;
  _impl_.save_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoSaveReq* MongoDBMsg::unsafe_arena_release_save_req() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.save_req)
  
  ::S2S::MongoSaveReq* temp = _impl_.save_req_;
  _impl_.save_req_ = nullptr;
  return temp;
}
inline ::S2S::MongoSaveReq* MongoDBMsg::_internal_mutable_save_req() {
  
  if (_impl_.save_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoSaveReq>(GetArenaForAllocation());
    _impl_.save_req_ = p;
  }
  return _impl_.save_req_;
}
inline ::S2S::MongoSaveReq* MongoDBMsg::mutable_save_req() {
  ::S2S::MongoSaveReq* _msg = _internal_mutable_save_req();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.save_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_save_req(::S2S::MongoSaveReq* save_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_req_;
  }
  if (save_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_req);
    if (message_arena != submessage_arena) {
      save_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.save_req_ = save_req;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.save_req)
}

// .S2S.MongoSaveRes save_res = 7;
inline bool MongoDBMsg::_internal_has_save_res() const {
  return this != internal_default_instance() && _impl_.save_res_ != nullptr;
}
inline bool MongoDBMsg::has_save_res() const {
  return _internal_has_save_res();
}
inline void MongoDBMsg::clear_save_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.save_res_ != nullptr) {
    delete _impl_.save_res_;
  }
  _impl_.save_res_ = nullptr;
}
inline const ::S2S::MongoSaveRes& MongoDBMsg::_internal_save_res() const {
  const ::S2S::MongoSaveRes* p = _impl_.save_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoSaveRes&>(
      ::S2S::_MongoSaveRes_default_instance_);
}
inline const ::S2S::MongoSaveRes& MongoDBMsg::save_res() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.save_res)
  return _internal_save_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_save_res(
    ::S2S::MongoSaveRes* save_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.save_res_);
  }
  _impl_.save_res_ = save_res;
  if (save_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.save_res)
}
inline ::S2S::MongoSaveRes* MongoDBMsg::release_save_res() {
  
  ::S2S::MongoSaveRes* temp = _impl_.save_res_;
  _impl_.save_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoSaveRes* MongoDBMsg::unsafe_arena_release_save_res() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.save_res)
  
  ::S2S::MongoSaveRes* temp = _impl_.save_res_;
  _impl_.save_res_ = nullptr;
  return temp;
}
inline ::S2S::MongoSaveRes* MongoDBMsg::_internal_mutable_save_res() {
  
  if (_impl_.save_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoSaveRes>(GetArenaForAllocation());
    _impl_.save_res_ = p;
  }
  return _impl_.save_res_;
}
inline ::S2S::MongoSaveRes* MongoDBMsg::mutable_save_res() {
  ::S2S::MongoSaveRes* _msg = _internal_mutable_save_res();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.save_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_save_res(::S2S::MongoSaveRes* save_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.save_res_;
  }
  if (save_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(save_res);
    if (message_arena != submessage_arena) {
      save_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.save_res_ = save_res;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.save_res)
}

// .S2S.MongoFindReq find_req = 10;
inline bool MongoDBMsg::_internal_has_find_req() const {
  return this != internal_default_instance() && _impl_.find_req_ != nullptr;
}
inline bool MongoDBMsg::has_find_req() const {
  return _internal_has_find_req();
}
inline void MongoDBMsg::clear_find_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.find_req_ != nullptr) {
    delete _impl_.find_req_;
  }
  _impl_.find_req_ = nullptr;
}
inline const ::S2S::MongoFindReq& MongoDBMsg::_internal_find_req() const {
  const ::S2S::MongoFindReq* p = _impl_.find_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoFindReq&>(
      ::S2S::_MongoFindReq_default_instance_);
}
inline const ::S2S::MongoFindReq& MongoDBMsg::find_req() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.find_req)
  return _internal_find_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_find_req(
    ::S2S::MongoFindReq* find_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.find_req_);
  }
  _impl_.find_req_ = find_req;
  if (find_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.find_req)
}
inline ::S2S::MongoFindReq* MongoDBMsg::release_find_req() {
  
  ::S2S::MongoFindReq* temp = _impl_.find_req_;
  _impl_.find_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoFindReq* MongoDBMsg::unsafe_arena_release_find_req() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.find_req)
  
  ::S2S::MongoFindReq* temp = _impl_.find_req_;
  _impl_.find_req_ = nullptr;
  return temp;
}
inline ::S2S::MongoFindReq* MongoDBMsg::_internal_mutable_find_req() {
  
  if (_impl_.find_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoFindReq>(GetArenaForAllocation());
    _impl_.find_req_ = p;
  }
  return _impl_.find_req_;
}
inline ::S2S::MongoFindReq* MongoDBMsg::mutable_find_req() {
  ::S2S::MongoFindReq* _msg = _internal_mutable_find_req();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.find_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_find_req(::S2S::MongoFindReq* find_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.find_req_;
  }
  if (find_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(find_req);
    if (message_arena != submessage_arena) {
      find_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, find_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.find_req_ = find_req;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.find_req)
}

// .S2S.MongoFindRes find_res = 11;
inline bool MongoDBMsg::_internal_has_find_res() const {
  return this != internal_default_instance() && _impl_.find_res_ != nullptr;
}
inline bool MongoDBMsg::has_find_res() const {
  return _internal_has_find_res();
}
inline void MongoDBMsg::clear_find_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.find_res_ != nullptr) {
    delete _impl_.find_res_;
  }
  _impl_.find_res_ = nullptr;
}
inline const ::S2S::MongoFindRes& MongoDBMsg::_internal_find_res() const {
  const ::S2S::MongoFindRes* p = _impl_.find_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoFindRes&>(
      ::S2S::_MongoFindRes_default_instance_);
}
inline const ::S2S::MongoFindRes& MongoDBMsg::find_res() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.find_res)
  return _internal_find_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_find_res(
    ::S2S::MongoFindRes* find_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.find_res_);
  }
  _impl_.find_res_ = find_res;
  if (find_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.find_res)
}
inline ::S2S::MongoFindRes* MongoDBMsg::release_find_res() {
  
  ::S2S::MongoFindRes* temp = _impl_.find_res_;
  _impl_.find_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoFindRes* MongoDBMsg::unsafe_arena_release_find_res() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.find_res)
  
  ::S2S::MongoFindRes* temp = _impl_.find_res_;
  _impl_.find_res_ = nullptr;
  return temp;
}
inline ::S2S::MongoFindRes* MongoDBMsg::_internal_mutable_find_res() {
  
  if (_impl_.find_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoFindRes>(GetArenaForAllocation());
    _impl_.find_res_ = p;
  }
  return _impl_.find_res_;
}
inline ::S2S::MongoFindRes* MongoDBMsg::mutable_find_res() {
  ::S2S::MongoFindRes* _msg = _internal_mutable_find_res();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.find_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_find_res(::S2S::MongoFindRes* find_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.find_res_;
  }
  if (find_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(find_res);
    if (message_arena != submessage_arena) {
      find_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, find_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.find_res_ = find_res;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.find_res)
}

// .S2S.MongoBatchFindReq batch_find_req = 12;
inline bool MongoDBMsg::_internal_has_batch_find_req() const {
  return this != internal_default_instance() && _impl_.batch_find_req_ != nullptr;
}
inline bool MongoDBMsg::has_batch_find_req() const {
  return _internal_has_batch_find_req();
}
inline void MongoDBMsg::clear_batch_find_req() {
  if (GetArenaForAllocation() == nullptr && _impl_.batch_find_req_ != nullptr) {
    delete _impl_.batch_find_req_;
  }
  _impl_.batch_find_req_ = nullptr;
}
inline const ::S2S::MongoBatchFindReq& MongoDBMsg::_internal_batch_find_req() const {
  const ::S2S::MongoBatchFindReq* p = _impl_.batch_find_req_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoBatchFindReq&>(
      ::S2S::_MongoBatchFindReq_default_instance_);
}
inline const ::S2S::MongoBatchFindReq& MongoDBMsg::batch_find_req() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.batch_find_req)
  return _internal_batch_find_req();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_batch_find_req(
    ::S2S::MongoBatchFindReq* batch_find_req) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_find_req_);
  }
  _impl_.batch_find_req_ = batch_find_req;
  if (batch_find_req) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.batch_find_req)
}
inline ::S2S::MongoBatchFindReq* MongoDBMsg::release_batch_find_req() {
  
  ::S2S::MongoBatchFindReq* temp = _impl_.batch_find_req_;
  _impl_.batch_find_req_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoBatchFindReq* MongoDBMsg::unsafe_arena_release_batch_find_req() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.batch_find_req)
  
  ::S2S::MongoBatchFindReq* temp = _impl_.batch_find_req_;
  _impl_.batch_find_req_ = nullptr;
  return temp;
}
inline ::S2S::MongoBatchFindReq* MongoDBMsg::_internal_mutable_batch_find_req() {
  
  if (_impl_.batch_find_req_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoBatchFindReq>(GetArenaForAllocation());
    _impl_.batch_find_req_ = p;
  }
  return _impl_.batch_find_req_;
}
inline ::S2S::MongoBatchFindReq* MongoDBMsg::mutable_batch_find_req() {
  ::S2S::MongoBatchFindReq* _msg = _internal_mutable_batch_find_req();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.batch_find_req)
  return _msg;
}
inline void MongoDBMsg::set_allocated_batch_find_req(::S2S::MongoBatchFindReq* batch_find_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.batch_find_req_;
  }
  if (batch_find_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(batch_find_req);
    if (message_arena != submessage_arena) {
      batch_find_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_find_req, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_find_req_ = batch_find_req;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.batch_find_req)
}

// .S2S.MongoBatchFindRes batch_find_res = 13;
inline bool MongoDBMsg::_internal_has_batch_find_res() const {
  return this != internal_default_instance() && _impl_.batch_find_res_ != nullptr;
}
inline bool MongoDBMsg::has_batch_find_res() const {
  return _internal_has_batch_find_res();
}
inline void MongoDBMsg::clear_batch_find_res() {
  if (GetArenaForAllocation() == nullptr && _impl_.batch_find_res_ != nullptr) {
    delete _impl_.batch_find_res_;
  }
  _impl_.batch_find_res_ = nullptr;
}
inline const ::S2S::MongoBatchFindRes& MongoDBMsg::_internal_batch_find_res() const {
  const ::S2S::MongoBatchFindRes* p = _impl_.batch_find_res_;
  return p != nullptr ? *p : reinterpret_cast<const ::S2S::MongoBatchFindRes&>(
      ::S2S::_MongoBatchFindRes_default_instance_);
}
inline const ::S2S::MongoBatchFindRes& MongoDBMsg::batch_find_res() const {
  // @@protoc_insertion_point(field_get:S2S.MongoDBMsg.batch_find_res)
  return _internal_batch_find_res();
}
inline void MongoDBMsg::unsafe_arena_set_allocated_batch_find_res(
    ::S2S::MongoBatchFindRes* batch_find_res) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.batch_find_res_);
  }
  _impl_.batch_find_res_ = batch_find_res;
  if (batch_find_res) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:S2S.MongoDBMsg.batch_find_res)
}
inline ::S2S::MongoBatchFindRes* MongoDBMsg::release_batch_find_res() {
  
  ::S2S::MongoBatchFindRes* temp = _impl_.batch_find_res_;
  _impl_.batch_find_res_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::S2S::MongoBatchFindRes* MongoDBMsg::unsafe_arena_release_batch_find_res() {
  // @@protoc_insertion_point(field_release:S2S.MongoDBMsg.batch_find_res)
  
  ::S2S::MongoBatchFindRes* temp = _impl_.batch_find_res_;
  _impl_.batch_find_res_ = nullptr;
  return temp;
}
inline ::S2S::MongoBatchFindRes* MongoDBMsg::_internal_mutable_batch_find_res() {
  
  if (_impl_.batch_find_res_ == nullptr) {
    auto* p = CreateMaybeMessage<::S2S::MongoBatchFindRes>(GetArenaForAllocation());
    _impl_.batch_find_res_ = p;
  }
  return _impl_.batch_find_res_;
}
inline ::S2S::MongoBatchFindRes* MongoDBMsg::mutable_batch_find_res() {
  ::S2S::MongoBatchFindRes* _msg = _internal_mutable_batch_find_res();
  // @@protoc_insertion_point(field_mutable:S2S.MongoDBMsg.batch_find_res)
  return _msg;
}
inline void MongoDBMsg::set_allocated_batch_find_res(::S2S::MongoBatchFindRes* batch_find_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.batch_find_res_;
  }
  if (batch_find_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(batch_find_res);
    if (message_arena != submessage_arena) {
      batch_find_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, batch_find_res, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.batch_find_res_ = batch_find_res;
  // @@protoc_insertion_point(field_set_allocated:S2S.MongoDBMsg.batch_find_res)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace S2S

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_5fmongo_5fproxy_2eproto
